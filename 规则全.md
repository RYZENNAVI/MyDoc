
# SQL ‰ªªÂä°ÁºñÂÜô‰∏éÂÆ°Êü•ËßÑÂàôÔºàÊ†πÊçÆÂØºÂ∏àÂèçÈ¶àÊï¥ÁêÜÔºâ


Êú¨ËßÑÂàô‰æùÊçÆ 2025 Âπ¥ 5 ÊúàÂØºÂ∏àÂ§öÊ¨°ÂèçÈ¶àÂÜÖÂÆπÊï¥ÁêÜÔºåÈÄÇÁî®‰∫é Sedrila È°πÁõÆ‰∏≠ SQL ‰ªªÂä°ÁöÑËÆæËÆ°‰∏éÂÆ°Êü•ÔºåÂ∞§ÂÖ∂ÊòØ `sql-*` Á≥ªÂàó‰ªªÂä°„ÄÇ


---


## ‚úÖ ‰ªªÂä°ËÆæËÆ°‰∏éÊï¥‰ΩìÁªìÊûÑ


1. **Áªü‰∏ÄÂëΩÂêçËßÑËåÉ**  
   ÈÅµÂæ™ Sedrila ÂëΩÂêçËßÑÂàôÔºöhttps://sedrila.readthedocs.io/en/latest/authors/#114-naming-conventions  
   - ‰ªªÂä°Êñá‰ª∂ÂêçÂøÖÈ°ªÂ∞èÂÜôÂºÄÂ§¥ÔºåÁî® `sql-` ÂâçÁºÄÔºõ
   - SQL ÂÖ≥ÈîÆËØç‰ΩøÁî®ÂÖ®Â§ßÂÜôÔºõ
   - Áî®ËøûÂ≠óÁ¨¶ËøûÊé•ÂêÑÈÉ®ÂàÜÔºåÂ¶ÇÔºö`sql-UPDATE-VIEW`„ÄÇ


2. **Êï¥‰ΩìËßÑÂàí‰ªªÂä°ÁªÑÔºàtaskgroupÔºâ**  
   ‰ªªÂä°ÈúÄÊàê‰ΩìÁ≥ªÔºåËÄÉËôëÂâçÁΩÆ‰ªªÂä°ÔºàassumesÔºâ‰∏éÊâÄÈúÄ‰ªªÂä°ÔºàrequiredÔºâÁöÑÂÆåÊï¥ÊÄß„ÄÇ


3. **ÂâçÁΩÆ‰ªªÂä°Êú™Êèê‰∫§Êó∂ÔºåÂãøÊèê‰∫§ÂêéÁª≠‰ªªÂä°**  
   ÊâÄ‰æùËµñÁöÑ `assumed` Âíå `required` ‰ªªÂä°ÈúÄÂ∑≤Êèê‰∫§ÊàñÂÆ°Ê†∏„ÄÇ


---


## üìò ‰ªªÂä°ÊñáÊ°£ÁªìÊûÑ‰∏éË°®ËææÊñπÂºè


4. **[BACKGROUND::...] ‰ªÖÁî®‰∫éÂä®Êú∫**  
   ‰∏çÂèØÁî®‰∫é‰ªãÁªç SQL Ê¶ÇÂøµÔºåÊ¶ÇÂøµÂ∫îÂÜôÂú®‰ªªÂä°Ê≠•È™§ÂºÄÂßãÈÉ®ÂàÜ„ÄÇ


5. **ÁõÆÊ†áÂàÜÁ±ªÂáÜÁ°Æ**  
   - ÊïôÂ≠¶ÊÄß‰ªªÂä°Ôºö‰ΩøÁî® `goal::idea` Êàñ `goal::experience`Ôºõ
   - ‰∫ßÂá∫Âûã‰ªªÂä°Ôºö‰ΩøÁî® `goal::product`„ÄÇ


6. **ÈÅøÂÖçËøáÂ§öÊ†áÈ¢òÂ±ÇÁ∫ß**  
   ‰ΩøÁî®‰∏âÁ∫ßÊ†áÈ¢ò `###` Âç≥ÂèØÔºåÈò≤Ê≠¢‰ªªÂä°ÊòæÂæóÊ∑∑‰π±„ÄÇ


7. **ÂëΩ‰ª§ÊÄßËØ≠Âè•‰∏çÂæó‰ΩúÊ†áÈ¢ò**  
   Â¶Ç `### ÊâßË°å‰ª•‰∏ã SQL ‰ª£Á†Å` Â∫îÊîπ‰∏∫ÂÖ∑ÊÑè‰πâÁöÑÊèèËø∞ÔºåÂ¶Ç `### Á§∫‰æãÔºöUPDATE Êìç‰ΩúÊºîÁ§∫`


8. **‰∏ä‰∏ãÊñáÊòéÁ°Æ**  
   ÊØè‰∏™ÊÆµËêΩÊàñ‰ª£Á†ÅÂùóÈúÄËØ¥ÊòéÂÖ∂ÁõÆÁöÑÔºåÈÅøÂÖçËØªËÄÖËø∑Â§±‰∏ä‰∏ãÊñá„ÄÇ


---


## üìñ Á§∫‰æã‰∏éÊñáÊ°£ÂºïÁî®


9. **Êèê‰æõÊùÉÂ®ÅÂèÇËÄÉÊù•Ê∫ê**  
   - `difficulty=1`: ÁªôÂá∫ÊòéÁ°Æ‰ΩçÁΩÆÊàñÊåáÂºïÔºõ
   - `difficulty=2`: ÂèØÁ®çÊ®°Á≥äÔºå‰ΩÜÈúÄÊúâÊèêÁ§∫Ôºõ
   - `difficulty=3`: ÂÖÅËÆ∏ÂÆΩÊ≥õÔºå‰ΩÜ‰ªçÈúÄËØ¥ÊòéÂ¶Ç‰ΩïÊâæÂà∞ËµÑÊñô„ÄÇ


10. **ÊñáÊ°£ÂºïÁî®ËØ≠Ê∞îÊòéÁ°Æ**  
    ‰∏çÁî®‚ÄúÂèØ‰ª•ÈòÖËØª‚ÄùÔºåËÄåÂ∫îËØ¥‚ÄúÂª∫ËÆÆ/ÈúÄË¶ÅÈòÖËØª‰ª•ÂÆåÊàê‰ªªÂä°‚Äù„ÄÇ


11. **Á§∫‰æãÈúÄ‰∏é‰ªªÂä°ÁõÆÊ†áÂÖ≥ËÅî**  
    Á§∫‰æã‰ª£Á†Å‰∏çÂ∫îÂ≠§Á´ãÔºåÈúÄËØ¥ÊòéÂÖ∂ÊïôÂ≠¶‰ΩúÁî®ÂíåÂêéÁª≠ÂÖ≥ËÅî„ÄÇ


---


## ‚ö†Ô∏è ÂÜÖÂÆπÂáÜÁ°ÆÊÄß‰∏éÊïôÂ≠¶ÂºïÂØº


12. **ÈÅøÂÖçÂê´Ê∑∑ÊèèËø∞**  
    Â¶Ç‚Äú‰ªäÂ§©‚ÄùÂ∫îÊåáÊòéÊòØÈùôÊÄÅÊó•ÊúüËøòÊòØÂä®ÊÄÅË°®ËææÂºè `today()`ÔºåÂπ∂ËØ¥ÊòéÂÖ∂ËØ≠Ê≥ïÊù•Ê∫ê„ÄÇ


13. **‰∏é‰ªªÂä°ÈöæÂ∫¶ÂØπÂ∫îÁöÑÂºïÂØºÂº∫Â∫¶**  
    - `difficulty=2`ÔºöÈúÄÈÄÇÂΩìÂºïÂØºÔºå‰∏çËÉΩË∑≥Ë∑ÉËøáÂ§ßÔºõ
    - Ëã•Ê∂âÂèäÁü•ËØÜÁÇπÊú™Âú®ÂâçÈù¢ËÆ≤ËøáÔºåÂ∫îÊèê‰æõÈòÖËØªÂèÇËÄÉ„ÄÇ


14. **Ê∏ÖÁêÜÊó†Áî® INCLUDE ËØ≠Âè•**  
    ‰∏çÂÜç‰ΩøÁî®ÁöÑ `[INCLUDE::...]` Â∫îÂΩªÂ∫ïÁßªÈô§ÔºåÈÅøÂÖçÂÜó‰Ωô„ÄÇ


---


## üß© ÂºÄÂèëÂçè‰Ωú‰∏éÁª¥Êä§ËßÑËåÉ


15. **‰ªªÂä°ÊîπÂêçÈúÄÂêåÊ≠• Issue Ê†áÈ¢ò**  
    ÈÅøÂÖçÂëΩÂêç‰∏ç‰∏ÄËá¥Â∏¶Êù•Âõ∞Êâ∞„ÄÇ


16. **Ê≤üÈÄö‰∏≠‰ΩøÁî®Ê†áËÆ∞ÁºñÂè∑ÔºàT1, T2, ...Ôºâ**  
    ÂõûÂ∫îÂèçÈ¶à„ÄÅÊèêÂá∫ÈóÆÈ¢òÊó∂Áªü‰∏Ä‰ΩøÁî®ÔºåÊñπ‰æøÈÄêÁÇπÂØπÈΩê„ÄÇ


17. **ÂêàÁêÜ‰ΩøÁî®Â∑•ÂÖ∑ÔºåÂπ∂ËØ¥Êòé‰ºòÂä£**  
    - SQLite Online ÁÆÄ‰æø‰ΩÜÁº∫‰πèÂéÜÂè≤ËÆ∞ÂΩïÔºõ
    - Êú¨Âú∞ `sqlite3` ‰∏ì‰∏ö‰ΩÜÁï•Â§çÊùÇÔºõ
    - ÂèØÊ∑∑Âêà‰ΩøÁî®Ôºå‰ΩÜÈúÄÊòéÁ°ÆËØ¥ÊòéÁêÜÁî±‰∏éÊé®ËçêÁî®Ê≥ï„ÄÇ


18. **Êé®ËçêÂ∑•ÂÖ∑ÈúÄËØ¥ÊòéÂÖ∂ÂèØÁî®ÊÄß‰∏éÊìç‰ΩúÊñπÊ≥ï**  
    Â¶Ç `sqlite3` ÂëΩ‰ª§Ë°åÂ∑•ÂÖ∑ÔºåÈúÄËØ¥ÊòéÁâàÊú¨ÈôêÂà∂Ôºà‰ªÖ 3.12+ÔºâÂèäÂ¶Ç‰Ωï‰ΩøÁî®„ÄÇ


19. **ÊãÜÂàÜÊó†ÂÖ≥ËÅîÂÜÖÂÆπËá≥Êñ∞‰ªªÂä°**  
    Â¶ÇÊ∂âÂèäËøõÈò∂Ê¶ÇÂøµÊàñÁ†îÁ©∂ÊÄßÈóÆÈ¢òÔºåÂ∫îÂè¶Âª∫‰ªªÂä°ËØ¥Êòé„ÄÇ


20. **Êèê‰∫§‰øÆÊîπÊó∂ÁÆÄÊ¥ÅÂõûÂ∫îÂç≥ÂèØ**
Ëã•Ê†πÊçÆÂª∫ËÆÆÂÅö‰∫ÜË∞ÉÊï¥ÔºåÂèØÁÆÄË¶ÅÂàóÂá∫Â∑≤ÂÆûÊñΩÁöÑÁÇπÔºåÂπ∂Âú® commit ‰∏≠Ê†áÊòéÁõ∏ÂÖ≥ Issue ÁºñÂè∑ÔºàÂ¶Ç #1Ôºâ„ÄÇÊó†ÈúÄÊí∞ÂÜôÂÜóÈïøÂõûÂ§çÔºõËã•ÂºïÂÖ•‰∫ÜÊñ∞ÂÜÖÂÆπÊàñÊÉ≥Ê≥ïÔºåÂèØÈÄÇÂΩìË°•ÂÖÖËØ¥Êòé„ÄÇ


21. **Â∞ÜÁ§∫‰æãËß£ÂÜ≥ÊñπÊ°àÁßªËá≥ÁßÅÊúâÂàÜÊîØ**
Ê†áÂáÜÁ≠îÊ°àÔºàÂ¶Ç Musterl√∂sungÔºâ‰∏çÂ∫îÁõ¥Êé•Âá∫Áé∞Âú®ÂÖ¨ÂºÄÂèØËßÅÁöÑ‰ªªÂä°Ê∫êÁ†Å‰∏≠ÔºåËÄåÂ∫îÂ≠òÊîæÂú®ÁßÅÊúâ‰ªìÂ∫ìÔºàÂ¶Ç altdir ÂàÜÊîØÔºâ‰∏≠„ÄÇÂú®‰ªªÂä°Êñá‰ª∂‰∏≠Âè™‰øùÁïô INCLUDE ÂºïÁî®ËØ≠Âè•Âç≥ÂèØ„ÄÇ
---


> ‚úÖ Âª∫ËÆÆÂú®ÊØèÊ¨°‰ªªÂä°ÁºñÂÜôÊàñÂÆ°Ê†∏Êó∂ÔºåÂ∞ÜÊú¨ËßÑÂàôÊ∏ÖÂçï‰Ωú‰∏∫ÂØπÁÖßÊ†áÂáÜÔºåÂπ∂ÊåÅÁª≠Êõ¥Êñ∞Ë°•ÂÖÖ„ÄÇ






# ÂêàÂπ∂ÁöÑ ProPra ÁºñÂÜô‰∏éËßÑÂàôÊñáÊ°£


‰ª•‰∏ã‰∏∫‰∏â‰ªΩÊñáÊ°£ÁöÑÊ±âËØ≠ÂêàÂπ∂ÁâàÔºå‰æùÁÖßÊïôÂ≠¶Áî®ÈÄîÂàÜÁ±ªÊï¥ÁêÜÔºö


## Êù•Ëá™Êñá‰ª∂1Ôºà‰ΩøÁî®ËØ¥Êòé‰∏é‰ªªÂä°ÁºñÂÜôÂéüÂàôÔºâ


# 1. For course teachers: How to use the ProPra


The target audience of this part of the document is course leads of ProPra courses.
These use `sedrila`'s `author` command for building the course website,
then the `instructor` command during the course.


1. Make sure you have a platform with an up-to-date Python (you need not know Python yourself).
   The ProPra itself assumes Debian/Ubuntu, but other variants of Linux (including on Windows WSL)
   will work just as well. Mac OS is not tested well, it may or may not work.  
   You need to know how to work with `git`.
2. Clone the present repo (see https://github.com/fubinf) and `cd propra-inf`.
3. Install the `pipx` Linux package.
4. Perform `pipx sedrila` to install the sedrila tool.  
   It serves as the build tool for the ProPra website (using its `author` command),
   as the tool for course participants (who use the `student` commmand) for submitting tasks and for
   reviewing their completion status, and
   as the tool for course instructors during the course (who use the `instructor` command)
   for reviewing student submissions and recording acceptance/rejection per task.
5. `cp sedrila.yaml my-sedrila.yaml`. Review and adapt the contents of `my-sedrila.yaml`.
   Consult the respective section of the [sedrila docs](https://sedrila.readthedocs.io/en/latest/authors)
   for what the entries mean.
   For the moment, no changes are needed.
   For running an actual course later, make the following changes:
    - you need to change `instructors`
    - you will want to change `title` and `name`
    - perhaps you want to remove some taskgroups; simply delete the respective line
    - if the course will be served by an Apache webserver, adapt `htaccess_template`.  
      Then you can simply copy the entire generated tree (containing both the student
      version and the instructor version of the website) into a publicly visible directory.
      The `htaccess_template` will result in an `.htaccess` file that grants visibility of the
      instructor part to instructors only.  
      If you are using a different webserver, you need to solve this problem yourself.
6. Perform `sedrila author --config my-sedrila.yaml --include_stage beta out`.
   This builds the ProPra student website in directory `out` and
   the ProPra instructor website in directory `out/instructor`.
7. Point your webbrowser to `out/index.html` to review the student version of
   the website; start at the homepage.  
   Then point it to `out/instructor/index.html` and read the instructor instructions on the homepage
   to understand what other preparations are required: Each instructor needs to create a GPG keypair
   and the public keys must be recorded in `my-sedrila.yaml`.
8. Copy the tree below `out` to a directory that will be served by your webserver.
   Tell your students the URL. Start your ProPra course. That's it.


If you want to modify some aspects of the ProPra content, read the "Customization" part
of the [sedrila `author` documentation](https://sedrila.readthedocs.io/en/latest/authors)
for the technical aspects.
Once you understood those, read on below for some content aspects.


----------------------
----------------------


# 2. For course authors: How to write tasks for a ProPra


The target audience of this part of the document is ProPra authors, not instructors and not students.


## 2.1 Principles


During the development of propra-inf, we have discovered the following principles
for its structure and attempt to obey them throughout:


- **SeDriLa template:**
  We use [sedrila](https://github.com/fubinf/sedrila) and follow its conventions
  (as described in [doc/authors.md](https://github.com/fubinf/sedrila/blob/main/doc/authors.md)).
- **regular structure:**
  All tasks are arranged into a simple chapter/taskgroup/task hierarchy.
  All tasks follow the same simple goal/background/instructions/submission section structure.
  There are [naming conventions](https://sedrila.readthedocs.io/en/latest/authors/#114-naming-conventions).
- **motivation focus:**
  Landing pages of chapters and taskgroups, goal sections of tasks
  greet students with a very short text that explains why they might be interested in this
  material.
- **all audiences:**
  We have tasks at different levels of difficulty.
  Most are aimed at "average" students, but others cater for stronger ones or (rarely) very weak ones.
- **fine granularity:**
  Our tasks are small, most in the 1.0...1.5 hour range (smaller if needed), with a 4 hours maximum.
- **independent tasks**:
  We strive to avoid strong dependencies between tasks, so students can pick what they want as much as possible.
- **heavy cross referencing:**
  Our tasks cross-reference each other a lot to show their interconnectedness and to support
  the fine granularity.
  There are standard types of cross-reference (`assumes`, `requires`, `explains`)
  and free-form ones (`[PARTREF]`).
- **glossary as glue:**
  A glossary entry lists all tasks referencing it and so serves as powerful glue in the
  cross-referencing structure.
- **simple reviewing:**
  The requirements for what students submit are geared towards making it simple and quick
  for instructors to review them, in particular by means of shell command protocols:
  [Kommandoprotokolle](ch/_include/Kommandoprotokolle.md).
- **avoid academic material:**
  We avoid duplicating (or even refering to) academic material known from lectures
  and prefer tasks that feel practical, real-worldly and that can be understood
  mostly with common sense.


Most of these principles serve the same purpose:
Maximizing the students' motivation to learn and try out things
because they find them interesting and relevant, find the tasks are fun to do,
and can observe their progress well.




## 2.2 Prior knowledge we assume students to have


We assume the students taking the propra-inf to have the following knowledge and skills:
- Boolean logic
- Programming:
  - procedural programming with variables and state and common control flow constructs:
    if-then-else, for, while
  - programming with parameterized subroutines
  - basic object-oriented programming: classes, methods, inheritance
  - functional programming style
- Corresponding syntax, semantics, and handling of Python,
  including basic use of lists, dictionaries, a small subset of `builtins`, but
  hardly anything from the standard library.


We do _not_ assume a good understanding of algorithms, data structures,
or software design, especially modularization, at least for tasks at difficulty level 2 (easy).




## 2.3 Learning to write ProPra task content


### 2.3.1 Learn `sedrila`


First, learn about `sedrila` in the
[README.md](https://github.com/fubinf/sedrila/blob/main/README.md) and
[authors.md](https://github.com/fubinf/sedrila/blob/main/doc/authors.md) parts of its documentation.




### 2.3.2 Use the task file template


When you start a new task description file,
copy [ch/template.md](../ch/template.md)
and use it as a template to have a clean up-to-date starting point.




### 2.3.3 Design for difficulty level


Writing a task works differently for different levels of task difficulty.  


Low-difficulty tasks (levels 1 and 2) have lots of detail and guidance in the task description.  
We do not assume these students can easily discriminate relevant from irrelevant information.
This means they have a hard time finding suitable pieces in a large documentation
and they need to be explained the significance of important information.
This, in turn, means we have to guide them to relevant information by pointing out
specific sources, sections in sources, names of commands/flags/classes/methods etc. they can use,
or sometimes providing exact pieces of code they need directly.


High-difficulty tasks (level 4) in contrast rely a lot on external documentation and
the students' own thinking.  


Medium-difficulty tasks (level 3) either have a mix of both or
are simple cases of what might otherwise be level 4.


There will be a tendency to underestimate how difficult a task is for the students,
so make sure a level-3 task leans more towards level-2 than towards level-4.
See macro `[HINT]` below.




### 2.3.4 The role of motivation


Given the huge freedom we give students and the superficial manner in which we
check their solutions, the ProPra's success depends massively on the students'
own motivation to learn.


Therefore,


- each taskgroup (the typical case) or individual task (as needed) should explain
  why the material will be (or can be) useful for a practicing software engineer;
- we should make every attempt at implementing one of the principles described in this article:
  [12 Prinzipien zur Motivation Lernender](https://link.springer.com/chapter/10.1007/978-3-658-26990-6_1)




### 2.3.5 Strive to re-use known didactic methods


When designing a set of tasks, many difficult didactic decisions must be made:
What to cover at all? In which depth? In which order?
Using which scenarios/examples/instructions/problems?


For answering these, there are two approaches:
- Find sources (in your specific topic area) that do it visibly well
  and copy many of their ideas or solutions
- Develop your decisions from well-tried general teaching methods.


For the latter, find a list of possible models (mostly geared to interactive teaching
in schools) here:
[Liste der Unterrichtsmethoden (Wikipedia)](https://de.wikipedia.org/wiki/Liste_der_Unterrichtsmethoden)




### 2.3.6 Work steps towards a task description


Suggested procedure:


1. Sketch a task group and its motivation.
2. List candidate tasks for the task group.
   Order them from more general (and useful for most people) to more specialized.  
   As a rule, the more general tasks should be difficulty 2, the specialized ones harder.  
   For the general tasks, split large ones (over two hours) into pieces, including
   pieces that should be "assumed" and then belong into
   different taskgroups or even chapters. Create placeholders with todo markers for those.
3. Outline a task description by selecting the section structure,
   in particular the section subtypes,
   and formulating the learning goal.
4. Draft the background (keep it short), instructions, and submission sections.
   Background is for motivation only, not for delivering required information.
5. Have someone else review the description for coherence between goal and instructions/submission
   and for appropriateness of the instructions given the difficulty.




### 2.3.7 `[SECTION::goal::...]`


The goal section


- is always rather short
- usually formulates one goal or two, not many
- aims at giving a quick idea what can be learned in this task to help students select tasks




### 2.3.8 `[SECTION::background::default]`


The background section


- is the only one that can be missing (but is usually present)
- should typically be short
- is _not_ used for providing background information that is part of the technical content
- is used only for _motivation_: Why or how it can be useful to have learned what can be learned here.




### 2.3.9 `[SECTION::instructions::type]`


The instruction section


- is the main part of the task
- can be rather long
- Instructions of type `detailed` at difficulty 2 (easy)
  carefully guide students through detailed, separate steps,
  that require understanding but little inventing (Bloom taxonomy level 3: apply),
  and use `[HINT]`s to help with the remaining inventing.
  The task should be easy for an average student working on it concentratedly.
  If there are many `[HINT]`s, students who'd prefer a more difficult task can make it
  more difficult for them by ignoring all the `[HINT]`s.
  Therefore, turning some understanding step into an inventive step and providing a `[HINT]` for it
  can be a useful task design technique.
- Instructions of type `loose` at difficulty 3 (medium)
  require much larger invention steps (Bloom taxonomy levels 4+5)
  but provide `[HINT]`s to make the task feasible for many more people.
  For difficult topics, difficulty 3 tasks sometimes use `detailed` instructions.
- Instructions of type `loose` or `tricky` at difficulty 4 (difficult)
  require still larger invention steps and much more self-steered
  work for the understanding parts as well (Bloom taxonomy levels 4+5).
  They provide few `[HINT]`s (for `tricky`) or none.
- At any difficulty level, the instructions can and should provide `[EQ]` reflection questions where
  students make up their minds what they think are advantages/disadvantages of something,
  what they like/dislike (and why) etc. (Bloom taxonomy level 6).
  (At difficulty 2, we will accept almost any response,
  at levels 3+4, the responses should be sensible.)


For the authors, tasks at difficulty 2 (easy) are much more work and also harder to get right
than those at difficulties 3 or 4.
However, the majority of our tasks needs to have difficulty 2 in order to address the majority
of our audience adequately.




### 2.3.10 [SECTION::submission::subtype1,subtype2]


The submission section


- usually contains only calls to one or more of the boilerplate blocks  
  ¬¥[INCLUDE::/_include/Submission-Kommandoprotokoll.md]` (if `[EC]` is present anywhere in the task)  
  `[INCLUDE::/_include/Submission-Quellcode.md]` (if `[ER]` is present)  
  `[INCLUDE::/_include/Submission-Markdowndokument.md]` (if `[EQ]` is present)  
  in a suitable order
- sometimes contains additional text, e.g. about what is or is not to be considered part of the source code
  or from what perspective to answer the `[EQ]` questions
- describes the character of the task via the submission subtypes:
    - `reflection`: There are `[EQ]` reflection questions
    - `information`: There are `[EQ]` fact-finding questions
    - `snippet`: The source code is to be viewed as a piecemeal collection of snippets
       or there are `[EQ]` questions to be answered with a bit of source code
    - `program`: The source code is an entire program, largely written by the student
    - `trace`: There are `[EC]` command instructions
- The idea of having these subtypes is that they help designing the task if you decide
  on the subtypes _before_ deciding on the details of the task.




### 2.3.11 [SECTION::instructor::GistOfPriorities]


The instructor section


- will announce in its title what the instructors should consider most important
  (usually: what indicates whether the student has learned the main teachings of the task)
- will reflect that priority in the order of information in the section body:
  important stuff first!
- will use terms "must" and "should" for indicating reasons for rejecting a task
  vs. points for mere feedback comments from the instructor to the student
- will include concrete example answers for all `[EQ]` questions (with discussion if needed)
- will include a concrete command protocol for all `[EC]` items
- will (if there are `[ER]` items) either include an example solution source code
  via an `[INCLUDE::ALT:sourcefile.xyz]` (embedded in triple backquotes for formatting)
  or point to it via `[TREEREF::/Chapter/Group/File]`




### 2.3.12 Language use (in German because we use German)


Zur Vermeidung inkonsistenter Sprache sollten wir einheitliche Begriffe f√ºr gleiche oder im
Kontext √§quivalente Begriffe verwenden.
TODO_3: In dieser Hinsicht (einheitliche Sprache und Begrifflichkeiten) gibt es noch viel zu tun.


- "Anwendung" statt Programm/Software oder auch Paket (wo sinnvoll)
- "Verzeichnis" statt Ordner
- "Defekt" in der Verwendung von Softwaretechnik, insbesondere in Abgrenzung zu "Fehler"
- "beispielsweise" statt "z.B." in Flie√ütext


Bei der Einf√ºhrung neuer Begriffe verwenden wir erstmals Anf√ºhrungszeichen. Wollen wir sie
anschlie√üend betont verwenden, machen wir sie *italic*. Bei der Einf√ºhrung von deutschen
Fachbegriffen erw√§hnen wir die korrekte englische Vokabel in Klammern.


Die Verwendung von Blocktext ist f√ºr Code oder Codeteile oder technische Bezeichner gedacht.


Wir k√ºrzen "Repository" mit "Repo" ab. Wir schreiben "Git", wenn wir die Software in einer
Art benennen, die kein Kommando ist. In Kommandos schreiben wir "git".


Wir vermeiden die Pluralisierung englischer W√∂rter, die auf y enden.
Generell beugen wir Fremdw√∂rter nach deutscher Rechtschreibung,
aber bevorzugen deutsche Begriffe, soweit die zumindest einigerma√üen gel√§ufig sind.


Wenn wir uns auf einen Teil der Universit√§t beziehen, nennen wir sie beim vollen Namen
und benutzen `<replacement id="...">...</replacement>` Tags, um die Angabe √§nderbar zu machen.




## 2.4 Technical development process




### 2.4.1 Development flow in general


- We are not using branches, all commits happen on `main` directly.
  We are a closed group and trust each other to work carefully.
- Integrate your local commits via 'git pull --rebase', not via 'merge'.
  Call `git config pull.rebase true` once to make this the default.
- Our staging happens via the `stage:` attribute of each task (see
  ["YAML top matter"](https://sedrila.readthedocs.io/en/latest/authors/#15-task-files-yaml-top-matter)).
  Changing this attribute replaces the pull request workflow typical in other open source projects.
- Tasks should be set to `stage: beta` only after a positive review by Lutz Prechelt.
  To start a review, assign `stage: alpha`,
  create an issue named `MyChapter/MyTaskgroup/MyTask` and assign it to `prechelt`.  




### 2.4.2 Task review flow


- If the reviewing takes more than one round, Lutz Prechelt will unassign himself from the issue each time
  he hands back the task to you.
  Remember to assign him again once your rework is done or nothing will happen.
- When submitting a task, consider whether you should mention special properties, design consideration, etc.
  If so, place them in the issue description.
  Otherwise, just put "nothing special" there.
- In the review dialog, each partner may introduce identifiers `T1`, `T2`, etc. for giving
  arbitrary review "topics" a name within the review.
  Refer to these when you respond and introduce additional ones (just keep counting) as needed.
  (`T3` is often a better identifier than `F3`/`A4`/`K5` from the task text, because the latter are
  not stable when steps are added or removed.)
- Always respond to such topics.
- Once a task has reached review, finishing it and getting it published should usually take
  priority over work on other tasks, so that we produce value for the students earlier.
- Once a task has reached review, make sure you mention the issue number (e.g. `#5`)
  in commit messages for that task so that the issue provides direct access to those commmits.
- If you rename a task, make sure to change the issue name.  
  If you rename a task group, make sure to change all respective issue names.




### 2.4.3 Task text layout conventions


- Line length: Restrict lines to 100 characters, prefer 80 where easily possible.
  Start each sentence on a new line.
  These two rules make the `diff` for later changes much more readable.
- Empty lines: Place two empty lines before each SECTION and before each heading.  
  Place one empty line before each blockmacro start line and after each blockmacro end line,
  but none after the start line (unless needed to repair a broken itemized list)
  or before the end line. See `ch/template_md`.
- Put hyperlinks on a separate line.


`[SECTION::instructions::...]`
- uses `###` subheadings for explaining task structure and supporting skimming
- puts each `[EQ]`, `[ER]`, `[EC]` in a separate paragraph (or sometimes list item)
- puts subsequent short preparatory steps (that do not need a `[EQ]`, `[ER]`, `[EC]` marker)
  into unnumbered list items
- prefers medium-long paragraphs otherwise




### 2.4.4 Working with the `altdir` submodule


Unfortunately, working with submodules in git is a bit tricky.


- **After `git pull`**, the submodule is always in the **"detached HEAD"** state,  
  because the super-repo references a specific commit ID and that commit is now checked out.  
  This is usually the most recent commit and identical to `origin/main`, but that is not guaranteed.
- If you want to make changes in the submodule (which is often the case),
  you may need to **clean it up**:
    - `(cd altdir; git log)` should show that `HEAD` and `origin/main` are aligned.
    - `(cd altdir; git switch main; git pull)` then brings the local `main` branch to that state.
- If in the check above `HEAD` and `origin/main` do _not_ match, someone messed up.  
  On 2024-07-02, for example, I found a branch `origin/detached` at `HEAD`,
  which was one commit ahead of `origin/main`.  
  After the cleanup described above, this commit was still missing.  
  It could be restored with `(cd altdir; git reset --hard origin/detached)`; alternatively, you could use  
  `git cherry-pick <commit-id>` ‚Äî but you should treat `git reset --hard` with proper caution.
- Until the next `git pull`, you can now **make commits** in the submodule.
- If you **forgot to clean up** and have already made local changes, you must  
  temporarily put them aside so they don't get wiped out during `git switch`:
    - `(cd altdir; git add myfile.xyz ...; git stash push -m myfile.xyz -- myfile.xyz ...)`  
      (`add` is only needed if `myfile.xyz` isn‚Äôt versioned yet.)
    - Then perform the cleanup and restore the file(s) with `(cd altdir; git stash pop)`.
    - If you committed such local changes despite all of git‚Äôs warnings:  
      Those commits will be lost during cleanup because they‚Äôre not connected to a proper branch.  
      Solution:  
      Remember the commit ID; perform cleanup as usual; reapply the commit using `cherry-pick`;  
      learn from this incident and take git's warnings more seriously next time.
- In the main repo, after changes, you may get the message  
  "fatal: cannot rebase with locally recorded submodule modifications" during `git pull`.  
  The reason and solution are described at  
  https://stackoverflow.com/questions/54215983/git-pull-error-fatal-cannot-rebase-with-locally-recorded-submodule-modificati  
  in the answer by Prechelt. The solution is usually:  
  `git pull --rebase --no-recurse-submodules`  
  `git submodule update --recursive`
- If you use a good IDE (such as PyCharm) for making your submodule changes,
  it will usually do much of the above for you automatically and life is a lot simpler.
  For keeping it simple, make sure you `pull` before you make changes, and
  `commit` and `push` those changes ASAP.
  The shorter your change episodes, the fewer git problems.






## Êù•Ëá™Êñá‰ª∂2ÔºàÂçèË∞É‰∏éÂëΩÂêçÁ∫¶ÂÆöÔºâ


# Zentrale Datei zur Koordindation unserer Arbeit




## 1. Konventionen


### 1.1 TODO-Marker


Folgende Konvention erlaubt TODO-Bedarf zu verwalten auf eine Weise, die
zugleich sehr bequem ist und sehr flexibel:


Wir schreiben an beliebige Textstellen, die noch Bearbeitungsbedarf haben oder welchen erkl√§ren
eine Marke der Form `TODO_n` oder `TODO_n_name`.  
Dabei hat `n` den Wert 1, 2 oder 3 und zeigt an, wie bald die √Ñnderung vermutlich
erfolgen wird (Zeitrahmen):


- `1`: Binnen weniger Tage (weil Kleinigkeit oder dringend)
- `2`: Binnen einiger Wochen. Kommt dran, sobald die 1er erledigt sind.
- `3`: Eines sch√∂nen Tages oder nie. Geringere Priorit√§t.
`name` ist der Benutzername der Person, die das TODO _voraussichtlich_ erledigen soll.


Verwendungsweise:


- Wir schreiben reichlich solche Marker √ºberall hin, wo sie n√ºtzlich sein k√∂nnten:
  - "Hier klafft noch eine gro√üe L√ºcke", z.B. ganze Aufgabengruppe, die noch leer ist.
  - "Hier habe ich gerade keine gute Idee", das muss ich sp√§ter noch mal verbessern
  - "Hier ist was nicht in Ordnung": Problem entdeckt, das bereinigt werden muss
  - etc.
- Wenn man die Person wei√ü, die das erledigen sollte, schreibt man ihren Namen dazu.
  (Meist den eigenen, ggf. aber auch einen fremden. Bei `3` sehr oft gar keinen.)
- Wenn man (egal wer) den Zeitrahmen f√ºr unpassend h√§lt, √§ndert man ihn, typischerweise nach oben.
- Wenn eine optionale √Ñnderung unrealistisch wird, entfernt man den ganzen TODO-Marker.
- Ziel ist, sich in der IDE jederzeit schnell einen _hochwertigen_ √úberblick verschaffen
  zu k√∂nnen, was alles zu tun ist, und das zu benutzen, damit 1er-√Ñnderungen immer z√ºgig
  erledigt werden. F√ºhlt sich gut an.
- Wenn man ein neues Feature der gegebenen Sprache, Bibliothek, Werkzeug etc. in einer Aufgabe
  eigentlich gern einbauen w√ºrde, aber noch nicht benutzen kann,
  weil das Feature beim aktuellen Betriebssystemstand gem√§√ü der Festlegung in
  `Basis/Unix-Umgebung/index.md` noch nicht verf√ºgbar ist, bitte einen Kommentar einf√ºgen,
  der beschreibt, was zur gegebenen Zeit k√ºnftig ge√§ndert werden k√∂nnte oder sollte.
  Diese "gegebene Zeit" wird durch die Versionsnummer des fraglichen Pakets beschrieben und
  das Ganze ist ein Stufe-3 TODO-Kommentar, z.B. so:  
  `<!-- TODO_3 Python 3.12: allow using sqlite3 command line client instead of SQLite Online -->`


### 1.2 Namenskonventionen


- Kapitelnamen beginnen mit Gro√übuchstaben
- Taskgroupnamen beginnen in der Regel mit Gro√übuchstaben
- Tasknamen folgen innerhalb einer Aufgabengruppe m√∂glichst einem festen Schema
  oder bilden zumindest Subgruppen mit je einem festen Namensschema.
- Namen enthalten keine Leerzeichen,
  sondern n√∂tigenfalls Underscores (wenn es um Python-Dateien geht)
  oder Trennstriche (sonst).




## 2. Korrekturbedarf am Bestand


### 2.0 Kaputte Links


Diese URLs sind verlinkt und funktionieren nicht oder nicht mehr.
Sie brauchen Reparatur oder Ersatz:


- https://about.gitlab.com/handbook/markdown-guide/
- ...




### 2.1 Korrekturbedarf bei einzelnen Dateien


In alphabetischer Reihenfolge der Dateinamen.


Einzelaufgaben:


- `json1` --> `json`
- `Git101`: Wie geht denn die Installation? Wo sind die Hyperlinks zu den URLs?
  Was bedeutet Klonen?
- `m_argparse`: Musterl√∂sung machen; `argparsetest.py` umbenennen.
- `Unix-Basiswerkzeuge`: Wir brauchen eine Mininmaleinf√ºhrung namens
  `Shell-Grundlagen` als brauchbare Aufgabe.


Sonderdateien:


- `process/how-to.md`: TODO_1_prechelt: Review-Vorgehen mit Issues beschreiben, aus `reviews.md` l√∂schen.
  F√ºr einzelne Rework-Auftr√§ge Issues anlegen und `reviews.md` entsprechend zur√ºckbauen.
- `glossary.md`: Bitte jeder durchgehen und erg√§nzen:  
  Was fehlt an Begriffen zu eigenen Aufgaben?  
  Was fehlt an Verweisen zwischen existierenden Begriffen und Aufgaben?
- `sedrila.css`: Farben besser abstimmen.
  Evtl. Farbschema von creativecommons benutzen?
  https://creativecommons.org/mission/downloads/ ganz unten.
- Aufgaben umbenennen: H√§ufige-Defektarten/*




### 2.2 Korrekturbedarf an gr√∂√üeren Strukturen


- Auf richtige Verwendung von "Hilfsbereich" (im Gegensatz zum Arbeitsbereich, siehe
  Aufgabe `Git101`) pr√ºfen+herstellen (Positivbeispiel: Unix-Links):
  ...
- Tasks so benennen, wie es sich aus authors.md 1.14 ergibt:
  https://sedrila.readthedocs.io/en/latest/authors/#114-naming-conventions  
  Erw√§hnungen an anderen Stellen mit √§ndern!
- Die Anwendung der Regeln f√ºr den Sprachgebrauch pr√ºfen/nachziehen
  wie in `how-to.md` beschrieben.
- Das Glossar durchsehen:
    - Schreibfehler und inhaltliche Fehler in Eintr√§gen
    - fehlende Quellenhinweise in Eintr√§gen
    - fehlende Querverweise zu anderen Glossareintr√§gen
    - fehlende Eintr√§ge f√ºr technische Bezeichner (z.B. Namen von Unix-Kommandos)
    - fehlende Verweise in Tasks auf solche und andere Glossareintr√§ge.


Vielleicht:
 
- `[SECTION::background::default]` √§ndern in `[SECTION::motivation::default]`,
  denn so wollen wir es mittlerweile ausschlie√ülich verwenden.
  Makro anpassen, Doku anpassen, alle Exemplare pr√ºfen.




### 2.3 Korrekturbedarf an sedrila


Bald:


- `webapp`: F√ºr `.prot` und `.md` Quell-Link erg√§nzen und bei `raw=` f√ºr `.prot` f√ºr
  mimetype `text/plain` sorgen
- `instructor`: Ungepr√ºfte Akzeptanz unterscheiden von gepr√ºfter.
- `author`: Wenn eine Aufgabe weggelassen wird, weil eine requires-Abh√§ngigkeit soft fehlt,
  sollte es eine Warnmeldung geben. Dass passiert bei `--stage beta`, wenn die Abh√§ngigkeit
  eine niedrigere stage hat.
- `author`: Tasks, die wegen ihrer stage fehlen, erscheinen derzeit f√§lschlich trotzdem in assumes.
- `author`: ZIP-Dateien sollen kein automatisches Unterverzeichnis enthalten.
- Defekt?: Aufgaben mit fehlendem `stage`-Eintrag, werden nicht in `done` gez√§hlt?
- Wenn bei `--include_stage beta` eine `required`-Abh√§ngigkeit nicht existiert,
  muss es eine Fehlermeldung geben, keinen toten Link.
  Und wenn eine `assumes`-Abh√§ngikeit nicht existiert oder sonst irgendein `PARTREF`
  auf eine zwar existente aber nicht eingeschlossene Aufgabe, dann sollte ein Pseudolink
  erscheinen, der mit "sorry, gibt es in dieser Fassung des ProPra leider nicht" dekoriert ist.
- `author` (Glossar): Zu einem `explains`-Eintrag in einer Task den passenden leeren Eintrag im
  Glossar automatisch erzeugen.
  Daf√ºr muss a) das Glossar in alphabetische Sortierung gezwungen werden (Fehlermeldung bei Verletzung) und
  b) bei `explains` erlaubt sein, Backquotes um einen Eintrag zu machen (die dann √ºbernommen, aber beim
  Sortieren ignoriert werden).
- `author` (Glossar): Eintr√§ge in sedrila aufsammeln und vorverarbeiten, um das Markdown zu erzeugen,
  das dann gerendert wird. Dabei kann man: a) bei Mehrfacheintr√§gen A, B einen separaten Eintrag
  f√ºr B mit Querverweis zuf√ºgen und b) Sortierung herstellen.
- `student`: `student.yaml` sollte die Kursgr√∂√üe in Stunden deklarieren.
  Dann kann die Aufgabentabelle Hurra schreien, wenn man fertig ist.


Gelegentlich:
- Konsistenzcheck, dass beim Aktualisieren eines Kurses keine bisherigen Aufgaben
  verschwinden.
- ch/Testen/index.md: eingebundenes graphviz darstellen (Plugin n√∂tig)?
  Geh√∂rt es allgemein in sedrila eingebaut, selbst solche Graphen zu erzeugen?
- `.htaccess` auch f√ºr Studis erzeugen. Beide sollten folgende Zeile enthalten  
  `AddCharset utf-8 .html .css .js .txt`  
  damit ein Crawler oder Browser korrekte Encodings erh√§lt.
  Browser l√∂sen das selbst, aber bei Crawlern, die Vanilla-`requests` einsetzen (wie unserer!),
  schl√§gt dessen die vom Standard vorgegebene ISO-8859-1-Annahme zu.
- F√ºgt man ein `explains:` bei der Index-Aufgabe einer Aufgabengruppe ein, hat das aktuell
  keine Auswirkung und im Glossar wird kein Link zu der Index-Aufgabe generiert. Bei einigen
  Glossareintr√§gen k√∂nnte es aber sinnvoll sein, dass unter `Explained by` ein Link zur
  zugeh√∂rigen Aufgabengruppe erzeugt wird, z.B. bei Debugging, Testen, Linter.




### 2.4 Antr√§ge an den Rechnerbetrieb


Was auf den Poolrechnern noch installiert werden muss:
- ...




### 2.5 Reviews Einzeldateien


Dieser Prozess ist beschrieben in `process/reviews.md`.




### 2.6 Globale Qualit√§tssicherung  TODO_3


Das machen wir, wenn eine gro√üe Konsolidierung angezeigt erscheint.


Pr√ºfpunkte:


- Einreichungsprozess von Studi an Tutor_in
- Fachliche Korrektheit aller Aufgaben
- Angemessenheit aller Aufgaben (ProPra-gem√§√üer Inhalt, Zeitwert)
- ??




## 3. Bedarf an und Ideen f√ºr Aufgaben zum Thema X


Das kann umfangreich werden und steht deshalb in einer separaten Datei namens
[aufgabenideen.md](aufgabenideen.md).




## 4. Weitere Ankn√ºpfungspunkte / Quellen




### 4.1 Initiative: Software Carpentry


Software Carpentry will Softwareentwicklung lehren f√ºr Computational Scientists.
Kursformat mit Lehrer.
https://software-carpentry.org/lessons/


Die haben 1998 begonnen und haben 2016 ganzheitlich Erfahrungen in einem Artikel dokumentiert:
https://f1000research.com/articles/3-62/v2  
Interessant sind z.B. Abschnitte 3 (Kursformat),
4.2 (live coding), 4.4 (open authoring), 4.8 (pair programming),
6 (collaborative lesson development),
8.2 (too slow and too fast), 8.3 (Is it supposed to hurt this much?), 8.4 (text editors),
8.5 (testing), 8.6 (watching vs. doing).


2019 wurde aus diesen Erfahrungen das Buch "Teaching Tech Together"
https://teachtogether.tech/en/index.html
(siehe ferner die Liste "What to read instead" auf der Homepage).




### 4.2 Buch: Software Design by Example


Ein Buch mit Beispielen (in Python), die sich als Anregung f√ºr Aufgaben eignen k√∂nnten:
https://third-bit.com/sdxpy/


Der Artikel "Twelve quick tips for software design"
https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1009809
gibt einfache _generelle_ Ratschl√§ge, wie man ein Programm entwerfen sollte.




### 4.3 Artikel: Ten simple rules for writing a technical book


Hat ein paar Ratschl√§ge, die auch f√ºr uns relevant sein k√∂nnten, insbesondere
Rule 4 (Start with a learner persona) und Rule 5 (Differentiate yourself)


https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1011305




## 4.4: Mentale Modelle aufzeichnen


Man k√∂nnte draw.io vorgeben, damit die Studis zu manchen Aufgaben ein Diagramm
abgeben und das den Instructors direkt in der webapp mit anzeigen.  
https://www.drawio.com/  (Open Source, Desktop oder [online](https://app.diagrams.net/?src=about))  
https://www.drawio.com/doc/faq/save-file-formats  
https://machow2.com/best-free-alternatives-visio-mac/




## Êù•Ëá™Êñá‰ª∂3ÔºàÁ´†ËäÇ‰∏é‰ªªÂä°ÂàõÊÑèÂª∫ËÆÆÔºâ


# Aufgabenideen zu Kapiteln




## ch/Bestandscode


Ideen f√ºr Aufgaben:


-    Mittelkleines Open-Source-Projekt P ausw√§hlen und Code holen
-    Ggf. Dokumentation sichten: Architektur/Entwurfsstruktur/Konzepte; Vorgaben und Verfahren zur Mitarbeit
-    Tutorial (wir machen mehrere Vorschl√§ge) √ºber Codeverstehen lesen. Ausprobieren. Wichtigste Erkenntnisse formulieren.
-    Mit eigenen Worten beschreiben: Was sind die wichtigsten Konzepte (nicht nur Klassennamen!) von der Architektur von P?
-    Welche Teile des Codes deckt die Testsuite gut ab? Schlecht ab?
-    Tests erg√§nzen
-    Eine gr√∂√üere Quellcode-Datei linter-konform machen.
-    In einer Datei technische Schulden finden und bereinigen.
-    Issue-Tracker sichten, einfache Issue ausw√§hlen und l√∂sen.
     Als Pull-Request einreichen; ggf. nachbessern; akzeptiert bekommen
-    F√ºr jede sonstige Aufgabe mit Erg√§nzung oder Verbesserung des Codes gibt es als optionale Zusatzaufgabe: als Pull-Request einreichen.
-    https://www.youtube.com/watch?v=M6_a2wBK-yc  Siehe Discord-Kommentar prechelt 2024-04-20 16:05
-    https://www.youtube.com/watch?v=2qYll837a_0  Siehe Discord-Kommentar prechelt 2024-04-20 16:21
-    https://www.youtube.com/watch?v=Bks59AaHe1c  Siehe Discord-Kommentar prechelt 2024-04-20 16:54


### Bestandscode/codereading (hofmann)


- An kleinen Beispielen verstehen, was Codeverstehen einfach oder schwierig macht:
  Namen, gute Hilfsabstraktionen, einfache statt clevere Logik.
- Gro√üe Codebasis holen. Obere Baumebenen durchsehen.
  Zweck der Level-1 und wichtiger Level-2-Verzeichnisse beschreiben.
  Wo gibt es Doku?
- Wo wird vermutlich Funktion X realisiert? Suche auf Basis von Namen:
  Verzeichnisse, Dateien, Klassen. Dann ggf. Verfolgung im Code mit Ctrl-Click.


### Bestandscode/logreading (hofmann)


Nutzung existierender Loggingfunktionalit√§t, um grobe Abl√§ufe in der Software zu verstehen.
Geht nat√ºrlich nur, wenn passende Info in den Logs vorhanden ist (existierende Logs)
oder beschafft werden kann (loglevel konfigurieren, dann passende Aktionen in der Software ausl√∂sen).


### Bestandscode/stepping (pietrak+hofmann)


Der Debugger ist nicht nur hilfreich zum Defektlokalisieren, sondern eventuell auch
zum Programmverstehen, weil sich der Computer niemals bei der Frage vertut,
was f√ºr Werte in Objekten stehen und welcher Programmzweig anzusteuern ist.
Au√üerdem hat er ein sehr viel gr√∂√üeres Arbeitsged√§chtnis als der Mensch.


Dies mit einem geeigneten Szenario verdeutlichen, vermutlich mit einem nicht sooo gro√üen Programm.


### Bestandscode/Refactoring* (pietrak)


- Am kleinen Beispiel √ºben: Code verst√§ndlicher machen durch
  Rename, Extract variable, Extract method.  
  Jede solche Operation kristallisiert und persistiert ein Br√∂ckchen von Verst√§ndnis,
  das man sich kurz zuvor erarbeitet hat.  
  Problem dabei ist die Unsicherheit, ob man etwas vielleicht falsch versteht,
  denn dann w√§ren die Ergebnisse u.U. irref√ºhrend.  
  Vielleicht als zwei Aufgaben:
  Erster Teil zum Lernen der Operationen und ihres Zwecks in Stil _detailed_/DIFF2,
  Rest dann selbst√§ndig in DIFF3. Der Code darf nicht allzu undurchsichtig sein.


Wie viel kann hier VS Code √ºberhaupt?


Hier sollen Methoden und Gr√ºnde f√ºrs Refactoring beleuchtet werden.
Guter Anlaufpunkt: <https://refactoring.guru/>


- IDE-Werkzeuge
  - Rename
  - Pull Members Up/Push Members Down
  - Invert Boolean
- Code Smells/SOLID:  
  Keine Debatte √ºber Sinn und Unsinn von "Clean Code", aber ein Gef√ºhl daf√ºr geben, welcher
  Code problematisch sein kann.
  Kleines oder mittelgro√ües realexistierendes Beispiel, wo SRP oder LSP verletzt sind,
  und so umstrukturiert werden soll, dass es erf√ºllt ist.


- Regeln f√ºr "guten Code"
  - Effektive Nutzung von Comments
  - Assertions
  - Tests
- Grenzen der IDE
  - Polymorphismus
  - dynamische Typisierung
    - TODO_3 Aufgabe f√ºr Typing in Python n√∂tig




## ch/Debugging (pietrak)


- Werkzeuge zum Debuggen
  - Logging
  - Automatisierte Tests (Verweis auf [ch/testen/testframeworks](ch/testen/testframeworks)?)
  - Rubberducking


- Ablauf des Debugging
  - Reproduktion
  - Hypothesenbildung und Hypothesenpr√ºfung




## ch/Bibliotheken


### Bibliotheken/stdlib (wegner)


Hier liegen zahlreiche kleine Aufgaben, mit denen man einzelne oft ben√∂tigte Teile der
Python-Standardbibliothek ausprobiert.


- itertools: eventuell eigenes kleines Modul zu funktionaler Programmierung in Python  
  Idiome recherchieren, Vergleich zwischen Schleifen und Itertools, Betrachtung bzgl.
  Effizienz, Lesbarkeit und Python Idiomen (was ist eher Python-artig?)
- functools: √§hnlich wie oder in Verbindung mit itertools
- abc: Teil der stdlib, aber noch unklar, ob es thematisch eher zu stlib oder Python geh√∂rt
- markup [DIFF::3]: Wahlaufgabe zum Bereich X="Structured Markup Processing Tools":
  W√§hlen Sie ein Modul aus dem Bereich X der Python-Standardbibliothek aus,
  das Sie noch nie benutzt haben.
  Verschaffen Sie sich in der Dokumentation einen √úberblick √ºber die Funktionalit√§t.
  Probieren Sie das Modul mit einem nicht zu simplen Anwendungsfall aus.  
  Abgabe:
  - Geben Sie den Code f√ºr Ihr Ausprobieren ab
  - Warum habe Sie gerade dieses Modul ausgesucht?
  - Hat das Modul eher mehr Funktionalit√§t als Sie erwartet h√§tten oder eher weniger?
    Was ist konkret mehr oder weniger da als erwartet?
  - War das Ausprobieren eher schwieriger als erwartet oder eher einfacher?
    Was war konkret schwieriger oder einfacher?
  (Wenn man hier√ºber eine Zeile zur Deklaration von X packt, kann man obigen Textblock
  per [INCLUDE] mehrfach wiederverwenden.)
- protocols [DIFF::3]: Wahlaufgabe zum Bereich X="Internet Protocols and Support"
- cryptoservice [DIFF::3]: Wahlaufgabe zum Bereich X="Cryptographic Services"
- fileformat [DIFF::3]: Wahlaufgabe zum Bereich X="File Formats"
- archives [DIFF::3]: Wahlaufgabe zum Bereich X="Data Compression and Archiving"


zu kl√§ren:


- os: sehr umfangreich, eventuell nur einzelne Teile?
- logging
- re: geh√∂rt vmtl eher zum Kapitel RegExp
- time: sollte das nochmal separat von datetime betrachtet werden oder mit in die Aufgabe
  integriert werden?
- sys
- collections
- math
- copy
- typing
- threading/multiprocessing
- warnings
- io
- uuid
- socket
- traceback
- base64
- operator


### Bibliotheken/pip-popular (N.N.)


- chardet (und charset-normalizer)




#### Bibliotheken/pip-popular pandas (N.N.)


- Pandas installieren, pandas101
- Struktur der Doku verstehen
- Theorie: Series, DataFrame, Index, MultiIndex: Zweck, Unterschiede, Gemeinsamkeiten.
- Pandas-Cheatsheet: CSV-Tabelle einlesen, diverse Arten von Datenumstrukturieren ausprobieren


#### Bibliotheken/pip-popular matplotlib (N.N.)


Assumes pandas


- matplotlib installieren
- Doku sichten, Grundkonzepte lernen (n√§mlich welche?)
- Barplot ausprobieren
- Boxplot ausprobieren
- Multi-Boxplot f√ºr Teilmengen von Variable B gem√§√ü der Gruppen laut Variable A
- einen komplexen Plot nachahmen, der visuell vorliegt und viele Konfig-Anpassungen braucht
  (Namen der n√∂tigen Konstrukte sind vorgegeben)
- Dito ohne Namensvorgaben.




### Bibliotheken/chooselib (N.N.)


Bibliothek f√ºr bestimmten Zweck suchen und erlernen.
Wichtige wiederkehrende T√§tigkeit in einem Entwickler_innenleben.


- Wo findet man Bibliotheken? PyPI ("pei-pi-ei").
  Stichwortsuche ausprobieren und sein blaues Wunder erleben ob der vielen Resultate.
- Nach welchen Merkmalen w√§hlt man eine Bibliothek aus?
  (Funktionsumfang, Qualit√§t der Dokumentation, Popularit√§t, Alter und Reife,
  kontinuierliche Pflege/Releases, Zustand Issuetracker, mag ich die Struktur der API?,
  Geschwindigkeit u.a. nichtfunktionale Eigenschaften, geringe Codegr√∂√üe/Aufgebl√§htheit,
  bisherige Sicherheitsl√ºcken und guter Umgang damit, ...)
- Wie entscheidet man √ºber diese Merkmale? (Recherche nach Wissen anderer; Prototypen bauen)
- 3 Fallstudien dazu
- Grundkonzepte verstehen!
- Wie lernt man das N√∂tige f√ºr einen schmalen Anwendungsfall (Doku vs. stackoverflow vs. ChatGPT)?


### Bibliotheken/Posix (N.N.)


- Aufgaben zum Kennenlernen des Unterschieds zwischen Posix-System und anderen unixoiden (sprich: Linux).






## ch/Sprachen


### Sprachen/Shell (condric+h√ºster?)


Puh, wie man folgendes in eine vern√ºnftige Lernreihenfolge bringt, ist nicht offensichtlich:  
Es w√§re sch√∂n, die Trennung zwischen der Shellsprache (inkl. builtins) und den Utilities zu vermitteln.  
Ferner den Unterschied zwischen `sh` und `bash`.


Die Utilities geh√∂ren an sich nicht hierhin, sondern ins Kapitel `Werkzeuge`.
Vermutlich f√ºhrt man hier von den allerwichtigsten Utilities (z.B. Dateihandling)
das Grundkonzept ein (weil man ohne sie nichts Sinnvolles tun kann) und
in `Werkzeuge` folgen sp√§ter diverse Optionen und Varianten der Benutzung?


W√∂rter, Kommandos, einfaches Quoting, Globbing, Redirect, Pipe.
if, Tests, for, while, exit codes,
shell vars, env vars,
single vs. double quote, backquote,
Quotes um Variablenverwendungen wg. m√∂glicher Blanks,
Shellprozeduren.


Typische Idiome in Shellskripten.




### Sprachen/Bash (condric+h√ºster?)


Die wichtigsten Erweiterungen gg√º. sh bez√ºglich Sprache, Variablen, Builtins, etc.


Ziel: Verstehen, dass sh (auf allen Plattformen vorhanden, wenn auch nicht immer _genau_ gleich)
und bash (deutlich erweitert) verschiedene Dinge sind.




### Sprachen/Regexp (h√ºster)


Basiskurs in "einfach", fortgeschrittenes Zeug in "mittel".
Immer m√∂glichst so eingekleidet, dass man einen realistischen Anwendungsfall kennenlernt.




### Sprachen/Python0 (alrwasheda)


Aufgaben mit DIFF1 als unvollkommene Starthilfe, √ºberwiegend f√ºr Leute mit zu niedrigem Wissen.
Wiederholung (manches ist aber auch neu!) der absoluten Essentials:
Kontrollstrukturen: if, elif, else, for, while, etc.
Keywords: def, return, break, continue, etc.
Datenstrukturen: list, dict, set etc.
OOP: class, self, Vererbung, super(), Objekterzeugung etc.
Gemischtes: tuple unpacking, ...


Vermutlich sinnvoll als L√ºckentext, sodass sehr kleine und eingegrenzte Aufgaben entstehen?




### Sprachen/Python (alrwasheda)


Fortgeschrittenere Konstrukte:
Projektstruktur: import, packages, modules, __init__.py, etc.
Context: with, open
try/except, eigene Exceptions, realistische Ausnahmebehandlung (try except raise und das dann ganz woanders fangen),
Typdeklarationen f√ºr Parameter und Resultate, Modul typing,
Typdeklarationen f√ºr Attribute, fast alles aus
https://medium.com/@rosk.abed/why-python-is-the-best-programming-language-so-far-5e481804159b,
builtins (all, any, get/set/hasattr, isinstance/issubclass, advanced print/list/dict/set,
str/bytes, sum, zip etc.)
und anderes mehr.


Alternativl√∂sung: wir weisen bei den Programmieraufgaben auf diese Konstrukte hin als
etwas, das man dabei lernen und benutzen kann oder soll.
Das ist aber nicht zielgenau, wenn die Aufgaben Spielraum bei der Entwurfsstruktur haben.


Aufgabe(n) zu den Dunder-Methoden von Klassen (z. B. `__init__`, `__bool__`, `__add__`,...) als
Folgeaufgabe zu ch/Sprachen/Python/PythonObjectsClassesIntro.md


String-Formatierung


### Sprachen/Pythonpraxis (prechelt)


1. Eine Reihe von Aufgaben, in denen nach und nach die CLI-Anwendung
`mlh` ("my little helpers") programmiert wird.
Diese b√ºndelt eine Reihe kleiner Utilities und
setzt argparse mit subcommands ein, um das zu strukturieren.
Diese Anwendung k√∂nnen die TN nach dem ProPra mitnehmen und ein langes und
abenteuerreiches Leben lang weiterbenutzen (und erg√§nzen).


Ideen f√ºr Teilanwendungen (in alphabetischer Reihenfolge):


- `diffenv`: Ein Skript, das die Verwaltung von Umgebungsvariablen in
  verschiedenen Umgebungen (Entwicklung, Test, Produktion usw.) erleichtert, indem es die Mengen
  von Umgebungsvariablen-Definitionen in zwei Dateien vergleicht.
  Es ignoriert also im Gegensatz zu normalem `diff ` sowohl die Werte dieser Variablen
  als auch die Reihenfolge ihrer Definition.
  Zeilen, die nicht die Form `A=b` oder `export A=b` haben, k√∂nnen wahlweise ignoriert, gez√§hlt,
  oder als Fehler (mit exit status) gemeldet werden.
  Mehrfache Definitionen derselben Variablen werden als Warnung gemeldet.
- `htmlprettify`: Liest ein HTML-Fragment von stdin und schreibt eine formatierte Fassung nach stdout.
- `sgrep`: Ein simples grep, das beliebige Trenner zul√§sst, anstatt immer nur '\n' als
  Trenner zu betrachten. Liest ggf. zun√§chst die ganze Datei in den Speicher.
  Default-Trenner ist '\n\n', sodass es ganze Abs√§tze ausspuckt anstatt Zeilen.
  Trenner ist eine regexp. `--color` markiert den Trefferstring rot.
- `pythonfraction`: https://third-bit.com/2025/05/18/two-thirds-of-a-language/


2. Eine Anwendung `linkcheck`, die einen Crawler realisiert, der die Verf√ºgbarkeit
von Teilen (HTML-Seiten, Bilder, JS-Dateien) in einem URL-Baum pr√ºft und verschiedene
fortgeschrittene Eigenschaften hat.
Teilaufgaben:


- `findlinks`: mit `bs4` die verschiedenen Sorten von Links auf einer Webseite extrahieren
  und ggf. zu absoluten Links erg√§nzen. Guten HTML-Parser installieren.
  Der Start-URL wird per Kommandozeilenparameter angegeben.
- `ratelimit`: Links in `deque`-Warteschlange einstellen und nacheinander per `urllib3` abarbeiten.
  Dabei ein ratelimit einhalten, das per default 4 Requests pro Sekunde betr√§gt, aber
  per Option `--maxfreq` ver√§ndert werden kann.
  Geht der Request (1) an einen URL "unterhalb" des Start-URLs, wird die HTML-Seite abgerufen
  und Links darauf extrahiert, geht er (2) an eine andere Adresse auf demselben Server,
  (3) an einen andereren Server, oder (4) liefert er eine andere Art von Datei als HTML,
  passiert keine Weiterverfolgung.
  In den F√§llen (2) und (3) wird HEAD benutzt statt GET.
  Der Statuscode wird registriert; Fehler werden ausgegeben.
- `multiqueue`: Jeder Server bekommt eine eigene Warteschlange.
  Wir betrachten jede Sekunde der Ausf√ºhrung als einen Block, in dem jeder Server `maxfreq`
  Requests bekommen darf. Ist eine Sekunde bei einem Server "voll", wechseln wir zum n√§chsten.
  Gewartet wird nur (und zwar bis zum Ende der aktuellen Sekunde), wenn alle Server "voll" sind.
- `monitoring`: Wir erzeugen eine fortlaufende Statusausgabe und eine Datei mit den Fehlern.
- `async`:
- `mlh`: als Subkommando in `mlh` integrieren.




Ferner evtl:


- `Code-Snippets`: Ein Tool, das es Entwicklern erm√∂glicht, Code-Snippets zu organisieren,
  zu suchen und wiederzuverwenden; Evt. gut geeignet um auch mlh als code-snippets aufzunehmen?


### Sprachen/Go (brandes)
- Compiler installieren, IDE einrichten (GoLand bevorzugt)
- Hello World und ein paar W√∂rter √ºber Packages
- Go f√ºr Python-Programmierer
  * Datentypen (casting und die meistbenutzten Typen)
  * Arrays, Slices, Maps
  * `if` und `for`, evtl. weitere einfachere Konstrukte
  * Funktionen (u. a. naked returns)
  * Pointers (evtl. im Zusammenhang mit C), pass-by-value oder -by-reference
  * Interfaces
- `go test`, `go build` und mehr zu Packages (Abh√§ngigkeiten, `"go.mod"`)
- `go install` vs `go get` (das zweite ist deprecated, nur als `go get -d` benutzen f√ºrs Herunterladen)
- File Management
  * file organizer - Dateien nach Typen sortieren
  * File system watcher?
- Multiprocessing (goroutines, channels, `select`, Mutex)
  * publisher/subscriber System
  * n-body Simulation?
  * Primzahlen bis n? (single- vs multithreaded, cpu/speicher trade-off)
  * job queue bzw. Task Scheduler?
- sqlite Integration
- Networking
  * (CRUD API?/ http messenger?)
  * file streaming √ºber TCP
  * Paket-Inspector (TCP/UDP Paket Monitoring)
- Dependency Injection und Decorator Patterns (wichtig im Kontext von Go)
- generell - Go Standardbibliothek?
- COG: Cogs of Go (cli Anwendung √§hnlich wie mlh)
  * `pin` - Alias zu dem Verzeichnis erstellen, wo das Kommando aufgerufen wurde;
  * `size` - Gro√üe von einer Datei bzw. einem Verzeichnis (Kombination von `du -sh` und `ls -l`);
  * `color` - Nimmt einen Hex-Farbcode (z. B. #123456) an und zeigt diese Farbe im Terminal;
  * `weather` - (vielleicht zu fortgeschritten) ip-address-geolocation-lookup + Wetterbericht f√ºr diesen Ort
- Effective Go, 100 Go Mistakes usw (https://github.com/dariubs/GoBooks)


### Sprachen/C (N.N.)


Kleiner Ausflug in die C-Programmierung, insbes. Zeiger, manuelle Speicherverwaltung.


- Compiler installieren, Hello World
- Datei einlesen, L√§nge der l√§ngsten und der k√ºrzesten (nichtleeren) Zeile bestimmen
- Datei einlesen, k√ºrzeste und l√§ngste Zeile aufbewahren (malloc).
  Wenn die l√§ngste Zeile sehr lang werden kann, muss man den Puffer immer wieder gr√∂√üer
  neu allokieren und den Inhalt umkopieren.
- malloc-Puffer √ºberschreiten, Crash erleben
- lokale Variable int a = 7, b = 9; Stapel-Layout anschauen und verstehen.
  Wohin f√ºhrt push: Zu h√∂heren Adressen oder niedrigeren?
  Wie gro√ü sind ints? Wie ist die Endianness?
- lokale Variable int16 a = 3, b = 4; *(char*)&a = "abcd"; a und b ansehen
- jetzt das Gleiche mit einem l√§ngeren String --> Crash
- Aus Unter-Unteraufruf gezielt eine lokale Variable im Unter-Aufruf ver√§ndern.
- Betriebssystemaufruf mit handgekl√∂ppelter Datenstruktur machen
- Evtl. eine Aufgabe, in der eine enge Schleife in Python durch Auslagern nach C
  enorm viel beschleunigt wird? Der Rest des Codes bleibt in Python.
  Man schreibt sich also eine ganz kleine Bibliothek f√ºr einen Spezialalgorithmus in C
  und bindet sie an.




### Sprachen/SQL (ruhe)


Ein paar Aufgaben zu mittelkomplexen Abfragen (mit etwas Verschacheltung)
und mittelkomplexen Updates.  
Assumes: sqlite




### Sprachen/DSLs (N.N.)


- Was ist eine DSL? (interne, externe)
- Grundlagen/h√§ufigste F√§lle von awk
- Grundlagen/h√§ufigste F√§lle von sed
- `jq`, `jid`, `jgrep`




### Sprachen/Andere-Shells (N.N.)


Alternative Shells.


- Fish1: die netten interaktiven Eigenschaften ausprobieren. Reflektion dar√ºber.
- Fish2: Ein Skript, das man oben f√ºr bash geschrieben (oder gelesen?) hat,
  nach `fish` umschreiben. Reflektion dar√ºber.
- Zsh: Die Anpassbarkeit bestaunen. Evtl. [Oh my zsh](https://ohmyz.sh/) durchst√∂bern.
  Reflektion dar√ºber.
- Powershell: 1-4 Aufgaben zu den ganz anderen Konzepten dieser Shell. (Ggf. eigene Gruppe.
  Geht nicht auf MacOS.)  
 




## ch/Testen (ruhe)


Folgende Voraussetzungen sollen gelten / geschaffen werden:


- Wichtige Begrifflichkeiten ist ein theoretischer Teil. Lesen und Antworten
- alle anderen Teilen sollen praktischer Natur sein
- hands-on Anteile sollen in GitHub realisiert werden
- Bestand
- optional: f√ºr die praktische Ausf√ºhrung ein SuT mit zu findenden Fehlern entwickeln (FastAPI, Flask)


Aufgabenbereiche:


- Wichtige Begrifflichkeiten
  - Fehler, Defekt und Fehlerart
    - √úbung
  - Testen, Debuggen und Qualit√§tssicherung
    - √úbung
  - Testfall, Testsammlung, Testplan und Testdaten
    - √úbung
- System Under Test (SuT)
  - Vorstellung des SuT
    - Bestandscode v1.0.0
    - Rest API Application v1.0.0, v1.1.0, v3.0.0
  - Implementierung
    - IDE
    - GitHub Action
- manuelles Testen
  - Testf√§lle erstellen in GitHub
  - Fehlerberichterstattung und -verfolgung in GitHub
- automatisiertes Testen
  - Testautomatisierungstools (Pytest, RF, Cypress, Locust, JMeter, SonarQube, Nessus)
  - Testarten
    - Unittests mit Pytest
    - Integrationstests mit RobotFramework
    - Systemtests mit Cypress (Optional + Cucumber mit Gherkin)
    - Last- und Performance Tests mit Locust
    - Sicherheitstests mit SonarQube (Nessus?)
    - Linter in der IDE
- Testdatenmanagement - statischer TF vs generischer TF
- Testabdeckung


- Resource: BugsInPy: a database of existing bugs in Python programs to enable controlled testing and debugging studies  
  <https://dl.acm.org/doi/10.1145/3368089.3417943>




## ch/Werkzeuge


### Werkzeuge/Bash2 (condric+h√ºster?)


- Umgang mit Dateien: ls, mv, rm, cp, mkdir, rmdir, ...  
  Lernziel: die F√§lle verstehen, in denen das einer GUI √ºberlegen ist: mit Globbing, mit mehreren Argumenten, mit speziellen Optionen
- Typische Helfer f√ºr die Shellprogrammierung: touch, cat, head, tail, grep, uniq, sort, find, awk, sed, xargs, tee, ...  
  Lernziel: Je mindestens einen gut erinnerbaren Anwendungsfall ausprobieren, in dem das Helferlein gute Dienste leistet.  
  Hier kommen nat√ºrlich nur noch die dran, die man nicht schon oben bei sprache/sh eingef√ºhrt hat.
- Typische Idiome der Shellprogrammierung.


Beispiele f√ºr interaktive Idiome:
- `cd -` zum Hin- und Herwechseln zwischen zwei Verzeichnissen
- Shellvars als Abk√ºrzung f√ºr lange Verzeichnisnamen
- `find`, um junge Dateien in Baum zu finden
- `grep`, um eine Datei per eindeutigen Inhaltsschlagwort wiederzufinden (etc.)
- `find` mit `grep`, um Dateien mit Wort X drin zu finden, dann `ls -lt` um davon die j√ºngste zu finden
  (mit entsprechender Story dazu, warum das praktisch sein kann: Nadel im Heuhaufen finden)
- .bashrc: pers√∂nlicher PATH, ein sch√∂ner Prompt, praktische aliases u.v.a.m.


Beispiele f√ºr programmatische Idiome:
- ...


### Werkzeuge/Netzwerk (condric)


- ssh (mehrere Aufgaben)
  - ssh-agent (alias ins .bashrc)
  - tmux, ...
- ping, rsync, curl, wget, ...


Lernziel ist immer, typische Anwendungsf√§lle und St√§rken zu verstehen.


### Werkzeuge/Admin (condric)


- lokales System, z.B. evtl.: w, uptime, whoami, df, du, tail -f, mount, ps, pgrep, kill/pkill, top/htop, ...  
  Lernziel: Situationen verstehen, in denen man das jeweils gebrauchen kann.
- Dateisystemaufbau: /bin, /usr, /var, /etc, /mnt, ...  
  Lernziel: Grobes Verst√§ndnis von "Was ist wo?"
- fortgeschrittenes Dateihandling: file, dd, tar, zip, gzip, ...
- root sein, z.B. evtl.: sudo (mit sudoers, visudo etc.), su, Ethos, Vorsicht, /etc/passwd, Gruppen/Gruppenrechte, ...


### Werkzeuge/Git (h√ºster)


Reizvolle didaktische Aufgabe!  
Was geh√∂rt zum Grundwissen, was ist schon deutlich fortgeschritten?  
Welche Konzepte muss man verstehen?  
Lernt man Idiome f√ºr h√§ufige Situationen lieber durch selbererfinden oder wie Vokabeln?


- [Git Book 1.1](https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control) lesen.  
  Zwecke: √Ñnderungen an Dateien und Dateinamen aufheben; √Ñnderungen beschreiben (commit msg);
  Autoren und Zeitpunkte festhalten; Daten zwischen Rechnern synchronisieren; gleichzeitige √Ñnderungen zusammenf√ºhren,
  Varianten parallel entwickeln (Zweige, branches); fremde √Ñnderungen pr√ºfen und √ºbernehmen;
  fremde √Ñnderungen teilweise √ºbernehmen; Backup.  
  Welche zwei sind am wertvollsten und warum?  
  Welche zwei benutzt man am meisten und warum?
- Wie es funktioniert:
  [Git Book 1.3](https://git-scm.com/book/en/v2/Getting-Started-What-is-Git%3F) lesen;
  nur auf der Kommandozeile kann man git entr√§tseln;
  intern werden die Snapshots (versionierte Zust√§nde des Dateibaums) dargestellt als drei Sorten von Objekten:
  blobs f√ºr Dateien, trees f√ºr Verzeichnisse (bestehend aus Pfadnamen mit zugeh√∂rigem blob oder tree),
  und commits f√ºr Snapshots.
  Jedes Objekt jeder Sorte wird durch einen Hashwert identifiziert.  
  Beispiel selber durchturnen: ...
- Logs, Refspecs
- Merge vs Rebase
- Ein Repo, mehrere Origins
- Arbeit mit Branches
- reset
- stash
- cherry-pick, rebase --interactive
- ...


Speziellerer Kram:


- Signing
- Squashing
- bisect
- ...




### Werkzeuge: sonstige Ideen


- Shell:
  - https://writing.kemitchell.com/2024/03/28/Pick-From-a-List-Tools
- IDE
  - Unterschied IDE und Editor
  - Projekterstellung
  - Code-Ausf√ºhrung in der IDE
  - Debugging
  - Refactoring
  - git-Integration
  - Integriertes Terminal
- Paketmanager
  - Welche stehen in meiner Sprache zur Verf√ºgung? Gibt es √ºberhaupt welche?
  - Welche Funktionen bietet ein Paketmanager?
  - Wie finde ich Pakete?
  - Fallbeispiel √ºber Probleme mit Paketmanagern
    - Eine der unz√§hligen Probleme mit npm heraussuchen, vielleicht mit einem Post Mortem.
      Aufgabe ist es herauszuarbeiten, was das Problem genau ist, ob es dauerhaft gefixt ist
      oder ob es √ºberhaupt fixbar ist.
      Nicht als Draufpr√ºgeln f√ºr npm, sondern f√ºr das Verstehen, dass die Nutzung von Fremdcode
      unter der Hand explodieren kann.
- Arbeitsplatzergonomie
  - *Pers√∂nlich* finde ich wichtig, dass die Studierenden nicht nur ihre Arbeitsumgebung im PC,
    sondern auch um ihren PC herum einrichten k√∂nnen.
    Meistens denkt man da erst dran, wenn es zu sp√§t ist.
    Maximal eine Aufgabe, darf nicht zu viel Platz beanspruchen.
- docker?




## ch/Web (m√ºllers, hofmann)


- assumes: Wissen √ºber http-Header, curl  
  https://icanhazdadjoke.com liefert im Browser etwas anderes als wenn man es mit curl abruft.
  Was vermuten Sie, wie funktioniert das? (User-Agent abfragen).
  Finden Sie eine Website, die Ihnen hilft zu pr√ºfen, ob die Voraussetzung f√ºr ihre Vermutung
  gegeben ist.
- Auf Grundlagen beschr√§nken; das ProPra ist kein Workshop f√ºr Spezialkenntnisse.  
- Frontend und Backend gemeinsam behandeln; Informatiker_innen sollten einen √úberblick haben.
- Behandlung von folgenden Themen: HTML, CSS, ~~Bootstrap~~ Tailwind(?), JavaScript,
  evtl. TypeScript, Flask, Django, Vue(?), React(?).


### Strukturvorschlag (basierend auf dem Stand vor den √Ñnderungen von Frau Atarim)


1. HTML
2. CSS
   - Jeweils eine Aufgabe f√ºr: Basics, h√§ufig benutzte Eigenschaften Box Model, Selectors, (Pseudo)Classes
   - Es gab auch noch Shorthands (border statt border-left/-right/-top/-bottom)
     und Margin/Border/Padding, weil das besondere Relevanz hat. -> Aufgabe Box Model.
   - Medien-Abfragen, "responsive" Design
   - Fortgeschritten: Calculated Properties und Variablen, Grid und Flex
   - Optional: Verwenden von CSS Frameworks
3. JS
   - Verwenden von Ressourcen die JS f√ºr Python-Devs erkl√§ren.
   - Kurze Erw√§hnung, dass Syntax C-Style ist. K√∂nnte man ggf. ausweisen.
     Erw√§hnung von function() {} vs () => {} als Frage, weil h√§ufiger Stolperstein.
   - Einf√ºhrung des DOM als Struktur mit einfachen Funktionen zur Manipulation
   - Einf√ºhrung der asynchronen Struktur von JS.
     - Gegen√ºberstellung von Callbacks vs async await, ggf IIFE. f√ºr async
   - Kleines Beispielprogramm mit wiederkehrenden Elementen bauen lassen
     - Klischeebeispiel: Todo-Liste. Nett, weil hohes feature ceiling
   - Auf Basis des Programms Teplates und Slots motivieren und umsetzen.
     Nicht immer wieder die gleichen Elemente anlegen m√ºssen!
   - Optional aufbauend auf Templates eigene Tags definieren.
     Hier w√ºrde ich die Semantic Tags kurz erw√§hnen.
   - Reactivity-Problem f√ºr die Template-Elemente erl√§utern.
     Beispiel: Durchstreichen nach Abhaken o.√§.
     Hier gibt es zwei Wege, das zu handlen:
     - Top-Down: Wir verwenden ein wenig von vue/reactivity und erkl√§ren anschlie√üend,
       dass so etwas mit Proxy-Klassen selbst gebaut werden kann.
       Optionale nachfolgende Aufgabe: Proxy selbst implementieren!
     - Bottom-Up: Wir streichen Drittanbieter-Bibliotheken und bauen direkt selbst einen Proxy.
       Nett, weil wenig Fremd-Information, aber sehr m√ºhsam mit vergleichsweise wenig Lerneffekt.
   - Shadow-DOM motivieren und ggf. mit Drittanbieter-Bibliothek anbinden
   - Struktur des Frameworks der Wahl pr√§sentieren und zeigen, wie es das gelernte umsetzt.
4. Backend mit Python
  - Flask, Django?




# Aufgabenideen ohne Heimat


- Lektion: K√§mpfe nicht gegen den Compiler an.
    - Sucht nach einer Umsetzung.
      Eine eigene Implementierung vs eine Implementierung der Standardbibliothek zu dekompilieren
      f√ºhrt nicht zum Ziel, Python optimiert recht wenig.
- ORM mit Python (Django oder sqlalchemy)
- Lernmethoden und Lernressourcen:
    - https://earthly.dev/blog/golang-streamers/
    - https://earthly.dev/blog/programming-language-improvements/
- DB-Programmierung-Antimuster vermeiden: SQL-Injektion, n+1 Queries
- Praxis Datenbankdesign
- Vergleich von sqlite, mysql, postgres; evtl. selber Aufsetzen und Ausprobieren.
- Machine Learning: Einfache Gehversuche mit scikit-learn (dubios: braucht erstmal Theoriewissen)



