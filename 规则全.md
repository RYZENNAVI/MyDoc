
# SQL 任务编写与审查规则（根据导师反馈整理）


本规则依据 2025 年 5 月导师多次反馈内容整理，适用于 Sedrila 项目中 SQL 任务的设计与审查，尤其是 `sql-*` 系列任务。


---


## ✅ 任务设计与整体结构


1. **统一命名规范**  
   遵循 Sedrila 命名规则：https://sedrila.readthedocs.io/en/latest/authors/#114-naming-conventions  
   - 任务文件名必须小写开头，用 `sql-` 前缀；
   - SQL 关键词使用全大写；
   - 用连字符连接各部分，如：`sql-UPDATE-VIEW`。


2. **整体规划任务组（taskgroup）**  
   任务需成体系，考虑前置任务（assumes）与所需任务（required）的完整性。


3. **前置任务未提交时，勿提交后续任务**  
   所依赖的 `assumed` 和 `required` 任务需已提交或审核。


---


## 📘 任务文档结构与表达方式


4. **[BACKGROUND::...] 仅用于动机**  
   不可用于介绍 SQL 概念，概念应写在任务步骤开始部分。


5. **目标分类准确**  
   - 教学性任务：使用 `goal::idea` 或 `goal::experience`；
   - 产出型任务：使用 `goal::product`。


6. **避免过多标题层级**  
   使用三级标题 `###` 即可，防止任务显得混乱。


7. **命令性语句不得作标题**  
   如 `### 执行以下 SQL 代码` 应改为具意义的描述，如 `### 示例：UPDATE 操作演示`


8. **上下文明确**  
   每个段落或代码块需说明其目的，避免读者迷失上下文。


---


## 📖 示例与文档引用


9. **提供权威参考来源**  
   - `difficulty=1`: 给出明确位置或指引；
   - `difficulty=2`: 可稍模糊，但需有提示；
   - `difficulty=3`: 允许宽泛，但仍需说明如何找到资料。


10. **文档引用语气明确**  
    不用“可以阅读”，而应说“建议/需要阅读以完成任务”。


11. **示例需与任务目标关联**  
    示例代码不应孤立，需说明其教学作用和后续关联。


---


## ⚠️ 内容准确性与教学引导


12. **避免含混描述**  
    如“今天”应指明是静态日期还是动态表达式 `today()`，并说明其语法来源。


13. **与任务难度对应的引导强度**  
    - `difficulty=2`：需适当引导，不能跳跃过大；
    - 若涉及知识点未在前面讲过，应提供阅读参考。


14. **清理无用 INCLUDE 语句**  
    不再使用的 `[INCLUDE::...]` 应彻底移除，避免冗余。


---


## 🧩 开发协作与维护规范


15. **任务改名需同步 Issue 标题**  
    避免命名不一致带来困扰。


16. **沟通中使用标记编号（T1, T2, ...）**  
    回应反馈、提出问题时统一使用，方便逐点对齐。


17. **合理使用工具，并说明优劣**  
    - SQLite Online 简便但缺乏历史记录；
    - 本地 `sqlite3` 专业但略复杂；
    - 可混合使用，但需明确说明理由与推荐用法。


18. **推荐工具需说明其可用性与操作方法**  
    如 `sqlite3` 命令行工具，需说明版本限制（仅 3.12+）及如何使用。


19. **拆分无关联内容至新任务**  
    如涉及进阶概念或研究性问题，应另建任务说明。


20. **提交修改时简洁回应即可**
若根据建议做了调整，可简要列出已实施的点，并在 commit 中标明相关 Issue 编号（如 #1）。无需撰写冗长回复；若引入了新内容或想法，可适当补充说明。


21. **将示例解决方案移至私有分支**
标准答案（如 Musterlösung）不应直接出现在公开可见的任务源码中，而应存放在私有仓库（如 altdir 分支）中。在任务文件中只保留 INCLUDE 引用语句即可。
---


> ✅ 建议在每次任务编写或审核时，将本规则清单作为对照标准，并持续更新补充。






# 合并的 ProPra 编写与规则文档


以下为三份文档的汉语合并版，依照教学用途分类整理：


## 来自文件1（使用说明与任务编写原则）


# 1. For course teachers: How to use the ProPra


The target audience of this part of the document is course leads of ProPra courses.
These use `sedrila`'s `author` command for building the course website,
then the `instructor` command during the course.


1. Make sure you have a platform with an up-to-date Python (you need not know Python yourself).
   The ProPra itself assumes Debian/Ubuntu, but other variants of Linux (including on Windows WSL)
   will work just as well. Mac OS is not tested well, it may or may not work.  
   You need to know how to work with `git`.
2. Clone the present repo (see https://github.com/fubinf) and `cd propra-inf`.
3. Install the `pipx` Linux package.
4. Perform `pipx sedrila` to install the sedrila tool.  
   It serves as the build tool for the ProPra website (using its `author` command),
   as the tool for course participants (who use the `student` commmand) for submitting tasks and for
   reviewing their completion status, and
   as the tool for course instructors during the course (who use the `instructor` command)
   for reviewing student submissions and recording acceptance/rejection per task.
5. `cp sedrila.yaml my-sedrila.yaml`. Review and adapt the contents of `my-sedrila.yaml`.
   Consult the respective section of the [sedrila docs](https://sedrila.readthedocs.io/en/latest/authors)
   for what the entries mean.
   For the moment, no changes are needed.
   For running an actual course later, make the following changes:
    - you need to change `instructors`
    - you will want to change `title` and `name`
    - perhaps you want to remove some taskgroups; simply delete the respective line
    - if the course will be served by an Apache webserver, adapt `htaccess_template`.  
      Then you can simply copy the entire generated tree (containing both the student
      version and the instructor version of the website) into a publicly visible directory.
      The `htaccess_template` will result in an `.htaccess` file that grants visibility of the
      instructor part to instructors only.  
      If you are using a different webserver, you need to solve this problem yourself.
6. Perform `sedrila author --config my-sedrila.yaml --include_stage beta out`.
   This builds the ProPra student website in directory `out` and
   the ProPra instructor website in directory `out/instructor`.
7. Point your webbrowser to `out/index.html` to review the student version of
   the website; start at the homepage.  
   Then point it to `out/instructor/index.html` and read the instructor instructions on the homepage
   to understand what other preparations are required: Each instructor needs to create a GPG keypair
   and the public keys must be recorded in `my-sedrila.yaml`.
8. Copy the tree below `out` to a directory that will be served by your webserver.
   Tell your students the URL. Start your ProPra course. That's it.


If you want to modify some aspects of the ProPra content, read the "Customization" part
of the [sedrila `author` documentation](https://sedrila.readthedocs.io/en/latest/authors)
for the technical aspects.
Once you understood those, read on below for some content aspects.


----------------------
----------------------


# 2. For course authors: How to write tasks for a ProPra


The target audience of this part of the document is ProPra authors, not instructors and not students.


## 2.1 Principles


During the development of propra-inf, we have discovered the following principles
for its structure and attempt to obey them throughout:


- **SeDriLa template:**
  We use [sedrila](https://github.com/fubinf/sedrila) and follow its conventions
  (as described in [doc/authors.md](https://github.com/fubinf/sedrila/blob/main/doc/authors.md)).
- **regular structure:**
  All tasks are arranged into a simple chapter/taskgroup/task hierarchy.
  All tasks follow the same simple goal/background/instructions/submission section structure.
  There are [naming conventions](https://sedrila.readthedocs.io/en/latest/authors/#114-naming-conventions).
- **motivation focus:**
  Landing pages of chapters and taskgroups, goal sections of tasks
  greet students with a very short text that explains why they might be interested in this
  material.
- **all audiences:**
  We have tasks at different levels of difficulty.
  Most are aimed at "average" students, but others cater for stronger ones or (rarely) very weak ones.
- **fine granularity:**
  Our tasks are small, most in the 1.0...1.5 hour range (smaller if needed), with a 4 hours maximum.
- **independent tasks**:
  We strive to avoid strong dependencies between tasks, so students can pick what they want as much as possible.
- **heavy cross referencing:**
  Our tasks cross-reference each other a lot to show their interconnectedness and to support
  the fine granularity.
  There are standard types of cross-reference (`assumes`, `requires`, `explains`)
  and free-form ones (`[PARTREF]`).
- **glossary as glue:**
  A glossary entry lists all tasks referencing it and so serves as powerful glue in the
  cross-referencing structure.
- **simple reviewing:**
  The requirements for what students submit are geared towards making it simple and quick
  for instructors to review them, in particular by means of shell command protocols:
  [Kommandoprotokolle](ch/_include/Kommandoprotokolle.md).
- **avoid academic material:**
  We avoid duplicating (or even refering to) academic material known from lectures
  and prefer tasks that feel practical, real-worldly and that can be understood
  mostly with common sense.


Most of these principles serve the same purpose:
Maximizing the students' motivation to learn and try out things
because they find them interesting and relevant, find the tasks are fun to do,
and can observe their progress well.




## 2.2 Prior knowledge we assume students to have


We assume the students taking the propra-inf to have the following knowledge and skills:
- Boolean logic
- Programming:
  - procedural programming with variables and state and common control flow constructs:
    if-then-else, for, while
  - programming with parameterized subroutines
  - basic object-oriented programming: classes, methods, inheritance
  - functional programming style
- Corresponding syntax, semantics, and handling of Python,
  including basic use of lists, dictionaries, a small subset of `builtins`, but
  hardly anything from the standard library.


We do _not_ assume a good understanding of algorithms, data structures,
or software design, especially modularization, at least for tasks at difficulty level 2 (easy).




## 2.3 Learning to write ProPra task content


### 2.3.1 Learn `sedrila`


First, learn about `sedrila` in the
[README.md](https://github.com/fubinf/sedrila/blob/main/README.md) and
[authors.md](https://github.com/fubinf/sedrila/blob/main/doc/authors.md) parts of its documentation.




### 2.3.2 Use the task file template


When you start a new task description file,
copy [ch/template.md](../ch/template.md)
and use it as a template to have a clean up-to-date starting point.




### 2.3.3 Design for difficulty level


Writing a task works differently for different levels of task difficulty.  


Low-difficulty tasks (levels 1 and 2) have lots of detail and guidance in the task description.  
We do not assume these students can easily discriminate relevant from irrelevant information.
This means they have a hard time finding suitable pieces in a large documentation
and they need to be explained the significance of important information.
This, in turn, means we have to guide them to relevant information by pointing out
specific sources, sections in sources, names of commands/flags/classes/methods etc. they can use,
or sometimes providing exact pieces of code they need directly.


High-difficulty tasks (level 4) in contrast rely a lot on external documentation and
the students' own thinking.  


Medium-difficulty tasks (level 3) either have a mix of both or
are simple cases of what might otherwise be level 4.


There will be a tendency to underestimate how difficult a task is for the students,
so make sure a level-3 task leans more towards level-2 than towards level-4.
See macro `[HINT]` below.




### 2.3.4 The role of motivation


Given the huge freedom we give students and the superficial manner in which we
check their solutions, the ProPra's success depends massively on the students'
own motivation to learn.


Therefore,


- each taskgroup (the typical case) or individual task (as needed) should explain
  why the material will be (or can be) useful for a practicing software engineer;
- we should make every attempt at implementing one of the principles described in this article:
  [12 Prinzipien zur Motivation Lernender](https://link.springer.com/chapter/10.1007/978-3-658-26990-6_1)




### 2.3.5 Strive to re-use known didactic methods


When designing a set of tasks, many difficult didactic decisions must be made:
What to cover at all? In which depth? In which order?
Using which scenarios/examples/instructions/problems?


For answering these, there are two approaches:
- Find sources (in your specific topic area) that do it visibly well
  and copy many of their ideas or solutions
- Develop your decisions from well-tried general teaching methods.


For the latter, find a list of possible models (mostly geared to interactive teaching
in schools) here:
[Liste der Unterrichtsmethoden (Wikipedia)](https://de.wikipedia.org/wiki/Liste_der_Unterrichtsmethoden)




### 2.3.6 Work steps towards a task description


Suggested procedure:


1. Sketch a task group and its motivation.
2. List candidate tasks for the task group.
   Order them from more general (and useful for most people) to more specialized.  
   As a rule, the more general tasks should be difficulty 2, the specialized ones harder.  
   For the general tasks, split large ones (over two hours) into pieces, including
   pieces that should be "assumed" and then belong into
   different taskgroups or even chapters. Create placeholders with todo markers for those.
3. Outline a task description by selecting the section structure,
   in particular the section subtypes,
   and formulating the learning goal.
4. Draft the background (keep it short), instructions, and submission sections.
   Background is for motivation only, not for delivering required information.
5. Have someone else review the description for coherence between goal and instructions/submission
   and for appropriateness of the instructions given the difficulty.




### 2.3.7 `[SECTION::goal::...]`


The goal section


- is always rather short
- usually formulates one goal or two, not many
- aims at giving a quick idea what can be learned in this task to help students select tasks




### 2.3.8 `[SECTION::background::default]`


The background section


- is the only one that can be missing (but is usually present)
- should typically be short
- is _not_ used for providing background information that is part of the technical content
- is used only for _motivation_: Why or how it can be useful to have learned what can be learned here.




### 2.3.9 `[SECTION::instructions::type]`


The instruction section


- is the main part of the task
- can be rather long
- Instructions of type `detailed` at difficulty 2 (easy)
  carefully guide students through detailed, separate steps,
  that require understanding but little inventing (Bloom taxonomy level 3: apply),
  and use `[HINT]`s to help with the remaining inventing.
  The task should be easy for an average student working on it concentratedly.
  If there are many `[HINT]`s, students who'd prefer a more difficult task can make it
  more difficult for them by ignoring all the `[HINT]`s.
  Therefore, turning some understanding step into an inventive step and providing a `[HINT]` for it
  can be a useful task design technique.
- Instructions of type `loose` at difficulty 3 (medium)
  require much larger invention steps (Bloom taxonomy levels 4+5)
  but provide `[HINT]`s to make the task feasible for many more people.
  For difficult topics, difficulty 3 tasks sometimes use `detailed` instructions.
- Instructions of type `loose` or `tricky` at difficulty 4 (difficult)
  require still larger invention steps and much more self-steered
  work for the understanding parts as well (Bloom taxonomy levels 4+5).
  They provide few `[HINT]`s (for `tricky`) or none.
- At any difficulty level, the instructions can and should provide `[EQ]` reflection questions where
  students make up their minds what they think are advantages/disadvantages of something,
  what they like/dislike (and why) etc. (Bloom taxonomy level 6).
  (At difficulty 2, we will accept almost any response,
  at levels 3+4, the responses should be sensible.)


For the authors, tasks at difficulty 2 (easy) are much more work and also harder to get right
than those at difficulties 3 or 4.
However, the majority of our tasks needs to have difficulty 2 in order to address the majority
of our audience adequately.




### 2.3.10 [SECTION::submission::subtype1,subtype2]


The submission section


- usually contains only calls to one or more of the boilerplate blocks  
  ´[INCLUDE::/_include/Submission-Kommandoprotokoll.md]` (if `[EC]` is present anywhere in the task)  
  `[INCLUDE::/_include/Submission-Quellcode.md]` (if `[ER]` is present)  
  `[INCLUDE::/_include/Submission-Markdowndokument.md]` (if `[EQ]` is present)  
  in a suitable order
- sometimes contains additional text, e.g. about what is or is not to be considered part of the source code
  or from what perspective to answer the `[EQ]` questions
- describes the character of the task via the submission subtypes:
    - `reflection`: There are `[EQ]` reflection questions
    - `information`: There are `[EQ]` fact-finding questions
    - `snippet`: The source code is to be viewed as a piecemeal collection of snippets
       or there are `[EQ]` questions to be answered with a bit of source code
    - `program`: The source code is an entire program, largely written by the student
    - `trace`: There are `[EC]` command instructions
- The idea of having these subtypes is that they help designing the task if you decide
  on the subtypes _before_ deciding on the details of the task.




### 2.3.11 [SECTION::instructor::GistOfPriorities]


The instructor section


- will announce in its title what the instructors should consider most important
  (usually: what indicates whether the student has learned the main teachings of the task)
- will reflect that priority in the order of information in the section body:
  important stuff first!
- will use terms "must" and "should" for indicating reasons for rejecting a task
  vs. points for mere feedback comments from the instructor to the student
- will include concrete example answers for all `[EQ]` questions (with discussion if needed)
- will include a concrete command protocol for all `[EC]` items
- will (if there are `[ER]` items) either include an example solution source code
  via an `[INCLUDE::ALT:sourcefile.xyz]` (embedded in triple backquotes for formatting)
  or point to it via `[TREEREF::/Chapter/Group/File]`




### 2.3.12 Language use (in German because we use German)


Zur Vermeidung inkonsistenter Sprache sollten wir einheitliche Begriffe für gleiche oder im
Kontext äquivalente Begriffe verwenden.
TODO_3: In dieser Hinsicht (einheitliche Sprache und Begrifflichkeiten) gibt es noch viel zu tun.


- "Anwendung" statt Programm/Software oder auch Paket (wo sinnvoll)
- "Verzeichnis" statt Ordner
- "Defekt" in der Verwendung von Softwaretechnik, insbesondere in Abgrenzung zu "Fehler"
- "beispielsweise" statt "z.B." in Fließtext


Bei der Einführung neuer Begriffe verwenden wir erstmals Anführungszeichen. Wollen wir sie
anschließend betont verwenden, machen wir sie *italic*. Bei der Einführung von deutschen
Fachbegriffen erwähnen wir die korrekte englische Vokabel in Klammern.


Die Verwendung von Blocktext ist für Code oder Codeteile oder technische Bezeichner gedacht.


Wir kürzen "Repository" mit "Repo" ab. Wir schreiben "Git", wenn wir die Software in einer
Art benennen, die kein Kommando ist. In Kommandos schreiben wir "git".


Wir vermeiden die Pluralisierung englischer Wörter, die auf y enden.
Generell beugen wir Fremdwörter nach deutscher Rechtschreibung,
aber bevorzugen deutsche Begriffe, soweit die zumindest einigermaßen geläufig sind.


Wenn wir uns auf einen Teil der Universität beziehen, nennen wir sie beim vollen Namen
und benutzen `<replacement id="...">...</replacement>` Tags, um die Angabe änderbar zu machen.




## 2.4 Technical development process




### 2.4.1 Development flow in general


- We are not using branches, all commits happen on `main` directly.
  We are a closed group and trust each other to work carefully.
- Integrate your local commits via 'git pull --rebase', not via 'merge'.
  Call `git config pull.rebase true` once to make this the default.
- Our staging happens via the `stage:` attribute of each task (see
  ["YAML top matter"](https://sedrila.readthedocs.io/en/latest/authors/#15-task-files-yaml-top-matter)).
  Changing this attribute replaces the pull request workflow typical in other open source projects.
- Tasks should be set to `stage: beta` only after a positive review by Lutz Prechelt.
  To start a review, assign `stage: alpha`,
  create an issue named `MyChapter/MyTaskgroup/MyTask` and assign it to `prechelt`.  




### 2.4.2 Task review flow


- If the reviewing takes more than one round, Lutz Prechelt will unassign himself from the issue each time
  he hands back the task to you.
  Remember to assign him again once your rework is done or nothing will happen.
- When submitting a task, consider whether you should mention special properties, design consideration, etc.
  If so, place them in the issue description.
  Otherwise, just put "nothing special" there.
- In the review dialog, each partner may introduce identifiers `T1`, `T2`, etc. for giving
  arbitrary review "topics" a name within the review.
  Refer to these when you respond and introduce additional ones (just keep counting) as needed.
  (`T3` is often a better identifier than `F3`/`A4`/`K5` from the task text, because the latter are
  not stable when steps are added or removed.)
- Always respond to such topics.
- Once a task has reached review, finishing it and getting it published should usually take
  priority over work on other tasks, so that we produce value for the students earlier.
- Once a task has reached review, make sure you mention the issue number (e.g. `#5`)
  in commit messages for that task so that the issue provides direct access to those commmits.
- If you rename a task, make sure to change the issue name.  
  If you rename a task group, make sure to change all respective issue names.




### 2.4.3 Task text layout conventions


- Line length: Restrict lines to 100 characters, prefer 80 where easily possible.
  Start each sentence on a new line.
  These two rules make the `diff` for later changes much more readable.
- Empty lines: Place two empty lines before each SECTION and before each heading.  
  Place one empty line before each blockmacro start line and after each blockmacro end line,
  but none after the start line (unless needed to repair a broken itemized list)
  or before the end line. See `ch/template_md`.
- Put hyperlinks on a separate line.


`[SECTION::instructions::...]`
- uses `###` subheadings for explaining task structure and supporting skimming
- puts each `[EQ]`, `[ER]`, `[EC]` in a separate paragraph (or sometimes list item)
- puts subsequent short preparatory steps (that do not need a `[EQ]`, `[ER]`, `[EC]` marker)
  into unnumbered list items
- prefers medium-long paragraphs otherwise




### 2.4.4 Working with the `altdir` submodule


Unfortunately, working with submodules in git is a bit tricky.


- **After `git pull`**, the submodule is always in the **"detached HEAD"** state,  
  because the super-repo references a specific commit ID and that commit is now checked out.  
  This is usually the most recent commit and identical to `origin/main`, but that is not guaranteed.
- If you want to make changes in the submodule (which is often the case),
  you may need to **clean it up**:
    - `(cd altdir; git log)` should show that `HEAD` and `origin/main` are aligned.
    - `(cd altdir; git switch main; git pull)` then brings the local `main` branch to that state.
- If in the check above `HEAD` and `origin/main` do _not_ match, someone messed up.  
  On 2024-07-02, for example, I found a branch `origin/detached` at `HEAD`,
  which was one commit ahead of `origin/main`.  
  After the cleanup described above, this commit was still missing.  
  It could be restored with `(cd altdir; git reset --hard origin/detached)`; alternatively, you could use  
  `git cherry-pick <commit-id>` — but you should treat `git reset --hard` with proper caution.
- Until the next `git pull`, you can now **make commits** in the submodule.
- If you **forgot to clean up** and have already made local changes, you must  
  temporarily put them aside so they don't get wiped out during `git switch`:
    - `(cd altdir; git add myfile.xyz ...; git stash push -m myfile.xyz -- myfile.xyz ...)`  
      (`add` is only needed if `myfile.xyz` isn’t versioned yet.)
    - Then perform the cleanup and restore the file(s) with `(cd altdir; git stash pop)`.
    - If you committed such local changes despite all of git’s warnings:  
      Those commits will be lost during cleanup because they’re not connected to a proper branch.  
      Solution:  
      Remember the commit ID; perform cleanup as usual; reapply the commit using `cherry-pick`;  
      learn from this incident and take git's warnings more seriously next time.
- In the main repo, after changes, you may get the message  
  "fatal: cannot rebase with locally recorded submodule modifications" during `git pull`.  
  The reason and solution are described at  
  https://stackoverflow.com/questions/54215983/git-pull-error-fatal-cannot-rebase-with-locally-recorded-submodule-modificati  
  in the answer by Prechelt. The solution is usually:  
  `git pull --rebase --no-recurse-submodules`  
  `git submodule update --recursive`
- If you use a good IDE (such as PyCharm) for making your submodule changes,
  it will usually do much of the above for you automatically and life is a lot simpler.
  For keeping it simple, make sure you `pull` before you make changes, and
  `commit` and `push` those changes ASAP.
  The shorter your change episodes, the fewer git problems.






## 来自文件2（协调与命名约定）


# Zentrale Datei zur Koordindation unserer Arbeit




## 1. Konventionen


### 1.1 TODO-Marker


Folgende Konvention erlaubt TODO-Bedarf zu verwalten auf eine Weise, die
zugleich sehr bequem ist und sehr flexibel:


Wir schreiben an beliebige Textstellen, die noch Bearbeitungsbedarf haben oder welchen erklären
eine Marke der Form `TODO_n` oder `TODO_n_name`.  
Dabei hat `n` den Wert 1, 2 oder 3 und zeigt an, wie bald die Änderung vermutlich
erfolgen wird (Zeitrahmen):


- `1`: Binnen weniger Tage (weil Kleinigkeit oder dringend)
- `2`: Binnen einiger Wochen. Kommt dran, sobald die 1er erledigt sind.
- `3`: Eines schönen Tages oder nie. Geringere Priorität.
`name` ist der Benutzername der Person, die das TODO _voraussichtlich_ erledigen soll.


Verwendungsweise:


- Wir schreiben reichlich solche Marker überall hin, wo sie nützlich sein könnten:
  - "Hier klafft noch eine große Lücke", z.B. ganze Aufgabengruppe, die noch leer ist.
  - "Hier habe ich gerade keine gute Idee", das muss ich später noch mal verbessern
  - "Hier ist was nicht in Ordnung": Problem entdeckt, das bereinigt werden muss
  - etc.
- Wenn man die Person weiß, die das erledigen sollte, schreibt man ihren Namen dazu.
  (Meist den eigenen, ggf. aber auch einen fremden. Bei `3` sehr oft gar keinen.)
- Wenn man (egal wer) den Zeitrahmen für unpassend hält, ändert man ihn, typischerweise nach oben.
- Wenn eine optionale Änderung unrealistisch wird, entfernt man den ganzen TODO-Marker.
- Ziel ist, sich in der IDE jederzeit schnell einen _hochwertigen_ Überblick verschaffen
  zu können, was alles zu tun ist, und das zu benutzen, damit 1er-Änderungen immer zügig
  erledigt werden. Fühlt sich gut an.
- Wenn man ein neues Feature der gegebenen Sprache, Bibliothek, Werkzeug etc. in einer Aufgabe
  eigentlich gern einbauen würde, aber noch nicht benutzen kann,
  weil das Feature beim aktuellen Betriebssystemstand gemäß der Festlegung in
  `Basis/Unix-Umgebung/index.md` noch nicht verfügbar ist, bitte einen Kommentar einfügen,
  der beschreibt, was zur gegebenen Zeit künftig geändert werden könnte oder sollte.
  Diese "gegebene Zeit" wird durch die Versionsnummer des fraglichen Pakets beschrieben und
  das Ganze ist ein Stufe-3 TODO-Kommentar, z.B. so:  
  `<!-- TODO_3 Python 3.12: allow using sqlite3 command line client instead of SQLite Online -->`


### 1.2 Namenskonventionen


- Kapitelnamen beginnen mit Großbuchstaben
- Taskgroupnamen beginnen in der Regel mit Großbuchstaben
- Tasknamen folgen innerhalb einer Aufgabengruppe möglichst einem festen Schema
  oder bilden zumindest Subgruppen mit je einem festen Namensschema.
- Namen enthalten keine Leerzeichen,
  sondern nötigenfalls Underscores (wenn es um Python-Dateien geht)
  oder Trennstriche (sonst).




## 2. Korrekturbedarf am Bestand


### 2.0 Kaputte Links


Diese URLs sind verlinkt und funktionieren nicht oder nicht mehr.
Sie brauchen Reparatur oder Ersatz:


- https://about.gitlab.com/handbook/markdown-guide/
- ...




### 2.1 Korrekturbedarf bei einzelnen Dateien


In alphabetischer Reihenfolge der Dateinamen.


Einzelaufgaben:


- `json1` --> `json`
- `Git101`: Wie geht denn die Installation? Wo sind die Hyperlinks zu den URLs?
  Was bedeutet Klonen?
- `m_argparse`: Musterlösung machen; `argparsetest.py` umbenennen.
- `Unix-Basiswerkzeuge`: Wir brauchen eine Mininmaleinführung namens
  `Shell-Grundlagen` als brauchbare Aufgabe.


Sonderdateien:


- `process/how-to.md`: TODO_1_prechelt: Review-Vorgehen mit Issues beschreiben, aus `reviews.md` löschen.
  Für einzelne Rework-Aufträge Issues anlegen und `reviews.md` entsprechend zurückbauen.
- `glossary.md`: Bitte jeder durchgehen und ergänzen:  
  Was fehlt an Begriffen zu eigenen Aufgaben?  
  Was fehlt an Verweisen zwischen existierenden Begriffen und Aufgaben?
- `sedrila.css`: Farben besser abstimmen.
  Evtl. Farbschema von creativecommons benutzen?
  https://creativecommons.org/mission/downloads/ ganz unten.
- Aufgaben umbenennen: Häufige-Defektarten/*




### 2.2 Korrekturbedarf an größeren Strukturen


- Auf richtige Verwendung von "Hilfsbereich" (im Gegensatz zum Arbeitsbereich, siehe
  Aufgabe `Git101`) prüfen+herstellen (Positivbeispiel: Unix-Links):
  ...
- Tasks so benennen, wie es sich aus authors.md 1.14 ergibt:
  https://sedrila.readthedocs.io/en/latest/authors/#114-naming-conventions  
  Erwähnungen an anderen Stellen mit ändern!
- Die Anwendung der Regeln für den Sprachgebrauch prüfen/nachziehen
  wie in `how-to.md` beschrieben.
- Das Glossar durchsehen:
    - Schreibfehler und inhaltliche Fehler in Einträgen
    - fehlende Quellenhinweise in Einträgen
    - fehlende Querverweise zu anderen Glossareinträgen
    - fehlende Einträge für technische Bezeichner (z.B. Namen von Unix-Kommandos)
    - fehlende Verweise in Tasks auf solche und andere Glossareinträge.


Vielleicht:
 
- `[SECTION::background::default]` ändern in `[SECTION::motivation::default]`,
  denn so wollen wir es mittlerweile ausschließlich verwenden.
  Makro anpassen, Doku anpassen, alle Exemplare prüfen.




### 2.3 Korrekturbedarf an sedrila


Bald:


- `webapp`: Für `.prot` und `.md` Quell-Link ergänzen und bei `raw=` für `.prot` für
  mimetype `text/plain` sorgen
- `instructor`: Ungeprüfte Akzeptanz unterscheiden von geprüfter.
- `author`: Wenn eine Aufgabe weggelassen wird, weil eine requires-Abhängigkeit soft fehlt,
  sollte es eine Warnmeldung geben. Dass passiert bei `--stage beta`, wenn die Abhängigkeit
  eine niedrigere stage hat.
- `author`: Tasks, die wegen ihrer stage fehlen, erscheinen derzeit fälschlich trotzdem in assumes.
- `author`: ZIP-Dateien sollen kein automatisches Unterverzeichnis enthalten.
- Defekt?: Aufgaben mit fehlendem `stage`-Eintrag, werden nicht in `done` gezählt?
- Wenn bei `--include_stage beta` eine `required`-Abhängigkeit nicht existiert,
  muss es eine Fehlermeldung geben, keinen toten Link.
  Und wenn eine `assumes`-Abhängikeit nicht existiert oder sonst irgendein `PARTREF`
  auf eine zwar existente aber nicht eingeschlossene Aufgabe, dann sollte ein Pseudolink
  erscheinen, der mit "sorry, gibt es in dieser Fassung des ProPra leider nicht" dekoriert ist.
- `author` (Glossar): Zu einem `explains`-Eintrag in einer Task den passenden leeren Eintrag im
  Glossar automatisch erzeugen.
  Dafür muss a) das Glossar in alphabetische Sortierung gezwungen werden (Fehlermeldung bei Verletzung) und
  b) bei `explains` erlaubt sein, Backquotes um einen Eintrag zu machen (die dann übernommen, aber beim
  Sortieren ignoriert werden).
- `author` (Glossar): Einträge in sedrila aufsammeln und vorverarbeiten, um das Markdown zu erzeugen,
  das dann gerendert wird. Dabei kann man: a) bei Mehrfacheinträgen A, B einen separaten Eintrag
  für B mit Querverweis zufügen und b) Sortierung herstellen.
- `student`: `student.yaml` sollte die Kursgröße in Stunden deklarieren.
  Dann kann die Aufgabentabelle Hurra schreien, wenn man fertig ist.


Gelegentlich:
- Konsistenzcheck, dass beim Aktualisieren eines Kurses keine bisherigen Aufgaben
  verschwinden.
- ch/Testen/index.md: eingebundenes graphviz darstellen (Plugin nötig)?
  Gehört es allgemein in sedrila eingebaut, selbst solche Graphen zu erzeugen?
- `.htaccess` auch für Studis erzeugen. Beide sollten folgende Zeile enthalten  
  `AddCharset utf-8 .html .css .js .txt`  
  damit ein Crawler oder Browser korrekte Encodings erhält.
  Browser lösen das selbst, aber bei Crawlern, die Vanilla-`requests` einsetzen (wie unserer!),
  schlägt dessen die vom Standard vorgegebene ISO-8859-1-Annahme zu.
- Fügt man ein `explains:` bei der Index-Aufgabe einer Aufgabengruppe ein, hat das aktuell
  keine Auswirkung und im Glossar wird kein Link zu der Index-Aufgabe generiert. Bei einigen
  Glossareinträgen könnte es aber sinnvoll sein, dass unter `Explained by` ein Link zur
  zugehörigen Aufgabengruppe erzeugt wird, z.B. bei Debugging, Testen, Linter.




### 2.4 Anträge an den Rechnerbetrieb


Was auf den Poolrechnern noch installiert werden muss:
- ...




### 2.5 Reviews Einzeldateien


Dieser Prozess ist beschrieben in `process/reviews.md`.




### 2.6 Globale Qualitätssicherung  TODO_3


Das machen wir, wenn eine große Konsolidierung angezeigt erscheint.


Prüfpunkte:


- Einreichungsprozess von Studi an Tutor_in
- Fachliche Korrektheit aller Aufgaben
- Angemessenheit aller Aufgaben (ProPra-gemäßer Inhalt, Zeitwert)
- ??




## 3. Bedarf an und Ideen für Aufgaben zum Thema X


Das kann umfangreich werden und steht deshalb in einer separaten Datei namens
[aufgabenideen.md](aufgabenideen.md).




## 4. Weitere Anknüpfungspunkte / Quellen




### 4.1 Initiative: Software Carpentry


Software Carpentry will Softwareentwicklung lehren für Computational Scientists.
Kursformat mit Lehrer.
https://software-carpentry.org/lessons/


Die haben 1998 begonnen und haben 2016 ganzheitlich Erfahrungen in einem Artikel dokumentiert:
https://f1000research.com/articles/3-62/v2  
Interessant sind z.B. Abschnitte 3 (Kursformat),
4.2 (live coding), 4.4 (open authoring), 4.8 (pair programming),
6 (collaborative lesson development),
8.2 (too slow and too fast), 8.3 (Is it supposed to hurt this much?), 8.4 (text editors),
8.5 (testing), 8.6 (watching vs. doing).


2019 wurde aus diesen Erfahrungen das Buch "Teaching Tech Together"
https://teachtogether.tech/en/index.html
(siehe ferner die Liste "What to read instead" auf der Homepage).




### 4.2 Buch: Software Design by Example


Ein Buch mit Beispielen (in Python), die sich als Anregung für Aufgaben eignen könnten:
https://third-bit.com/sdxpy/


Der Artikel "Twelve quick tips for software design"
https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1009809
gibt einfache _generelle_ Ratschläge, wie man ein Programm entwerfen sollte.




### 4.3 Artikel: Ten simple rules for writing a technical book


Hat ein paar Ratschläge, die auch für uns relevant sein könnten, insbesondere
Rule 4 (Start with a learner persona) und Rule 5 (Differentiate yourself)


https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1011305




## 4.4: Mentale Modelle aufzeichnen


Man könnte draw.io vorgeben, damit die Studis zu manchen Aufgaben ein Diagramm
abgeben und das den Instructors direkt in der webapp mit anzeigen.  
https://www.drawio.com/  (Open Source, Desktop oder [online](https://app.diagrams.net/?src=about))  
https://www.drawio.com/doc/faq/save-file-formats  
https://machow2.com/best-free-alternatives-visio-mac/




## 来自文件3（章节与任务创意建议）


# Aufgabenideen zu Kapiteln




## ch/Bestandscode


Ideen für Aufgaben:


-    Mittelkleines Open-Source-Projekt P auswählen und Code holen
-    Ggf. Dokumentation sichten: Architektur/Entwurfsstruktur/Konzepte; Vorgaben und Verfahren zur Mitarbeit
-    Tutorial (wir machen mehrere Vorschläge) über Codeverstehen lesen. Ausprobieren. Wichtigste Erkenntnisse formulieren.
-    Mit eigenen Worten beschreiben: Was sind die wichtigsten Konzepte (nicht nur Klassennamen!) von der Architektur von P?
-    Welche Teile des Codes deckt die Testsuite gut ab? Schlecht ab?
-    Tests ergänzen
-    Eine größere Quellcode-Datei linter-konform machen.
-    In einer Datei technische Schulden finden und bereinigen.
-    Issue-Tracker sichten, einfache Issue auswählen und lösen.
     Als Pull-Request einreichen; ggf. nachbessern; akzeptiert bekommen
-    Für jede sonstige Aufgabe mit Ergänzung oder Verbesserung des Codes gibt es als optionale Zusatzaufgabe: als Pull-Request einreichen.
-    https://www.youtube.com/watch?v=M6_a2wBK-yc  Siehe Discord-Kommentar prechelt 2024-04-20 16:05
-    https://www.youtube.com/watch?v=2qYll837a_0  Siehe Discord-Kommentar prechelt 2024-04-20 16:21
-    https://www.youtube.com/watch?v=Bks59AaHe1c  Siehe Discord-Kommentar prechelt 2024-04-20 16:54


### Bestandscode/codereading (hofmann)


- An kleinen Beispielen verstehen, was Codeverstehen einfach oder schwierig macht:
  Namen, gute Hilfsabstraktionen, einfache statt clevere Logik.
- Große Codebasis holen. Obere Baumebenen durchsehen.
  Zweck der Level-1 und wichtiger Level-2-Verzeichnisse beschreiben.
  Wo gibt es Doku?
- Wo wird vermutlich Funktion X realisiert? Suche auf Basis von Namen:
  Verzeichnisse, Dateien, Klassen. Dann ggf. Verfolgung im Code mit Ctrl-Click.


### Bestandscode/logreading (hofmann)


Nutzung existierender Loggingfunktionalität, um grobe Abläufe in der Software zu verstehen.
Geht natürlich nur, wenn passende Info in den Logs vorhanden ist (existierende Logs)
oder beschafft werden kann (loglevel konfigurieren, dann passende Aktionen in der Software auslösen).


### Bestandscode/stepping (pietrak+hofmann)


Der Debugger ist nicht nur hilfreich zum Defektlokalisieren, sondern eventuell auch
zum Programmverstehen, weil sich der Computer niemals bei der Frage vertut,
was für Werte in Objekten stehen und welcher Programmzweig anzusteuern ist.
Außerdem hat er ein sehr viel größeres Arbeitsgedächtnis als der Mensch.


Dies mit einem geeigneten Szenario verdeutlichen, vermutlich mit einem nicht sooo großen Programm.


### Bestandscode/Refactoring* (pietrak)


- Am kleinen Beispiel üben: Code verständlicher machen durch
  Rename, Extract variable, Extract method.  
  Jede solche Operation kristallisiert und persistiert ein Bröckchen von Verständnis,
  das man sich kurz zuvor erarbeitet hat.  
  Problem dabei ist die Unsicherheit, ob man etwas vielleicht falsch versteht,
  denn dann wären die Ergebnisse u.U. irreführend.  
  Vielleicht als zwei Aufgaben:
  Erster Teil zum Lernen der Operationen und ihres Zwecks in Stil _detailed_/DIFF2,
  Rest dann selbständig in DIFF3. Der Code darf nicht allzu undurchsichtig sein.


Wie viel kann hier VS Code überhaupt?


Hier sollen Methoden und Gründe fürs Refactoring beleuchtet werden.
Guter Anlaufpunkt: <https://refactoring.guru/>


- IDE-Werkzeuge
  - Rename
  - Pull Members Up/Push Members Down
  - Invert Boolean
- Code Smells/SOLID:  
  Keine Debatte über Sinn und Unsinn von "Clean Code", aber ein Gefühl dafür geben, welcher
  Code problematisch sein kann.
  Kleines oder mittelgroßes realexistierendes Beispiel, wo SRP oder LSP verletzt sind,
  und so umstrukturiert werden soll, dass es erfüllt ist.


- Regeln für "guten Code"
  - Effektive Nutzung von Comments
  - Assertions
  - Tests
- Grenzen der IDE
  - Polymorphismus
  - dynamische Typisierung
    - TODO_3 Aufgabe für Typing in Python nötig




## ch/Debugging (pietrak)


- Werkzeuge zum Debuggen
  - Logging
  - Automatisierte Tests (Verweis auf [ch/testen/testframeworks](ch/testen/testframeworks)?)
  - Rubberducking


- Ablauf des Debugging
  - Reproduktion
  - Hypothesenbildung und Hypothesenprüfung




## ch/Bibliotheken


### Bibliotheken/stdlib (wegner)


Hier liegen zahlreiche kleine Aufgaben, mit denen man einzelne oft benötigte Teile der
Python-Standardbibliothek ausprobiert.


- itertools: eventuell eigenes kleines Modul zu funktionaler Programmierung in Python  
  Idiome recherchieren, Vergleich zwischen Schleifen und Itertools, Betrachtung bzgl.
  Effizienz, Lesbarkeit und Python Idiomen (was ist eher Python-artig?)
- functools: ähnlich wie oder in Verbindung mit itertools
- abc: Teil der stdlib, aber noch unklar, ob es thematisch eher zu stlib oder Python gehört
- markup [DIFF::3]: Wahlaufgabe zum Bereich X="Structured Markup Processing Tools":
  Wählen Sie ein Modul aus dem Bereich X der Python-Standardbibliothek aus,
  das Sie noch nie benutzt haben.
  Verschaffen Sie sich in der Dokumentation einen Überblick über die Funktionalität.
  Probieren Sie das Modul mit einem nicht zu simplen Anwendungsfall aus.  
  Abgabe:
  - Geben Sie den Code für Ihr Ausprobieren ab
  - Warum habe Sie gerade dieses Modul ausgesucht?
  - Hat das Modul eher mehr Funktionalität als Sie erwartet hätten oder eher weniger?
    Was ist konkret mehr oder weniger da als erwartet?
  - War das Ausprobieren eher schwieriger als erwartet oder eher einfacher?
    Was war konkret schwieriger oder einfacher?
  (Wenn man hierüber eine Zeile zur Deklaration von X packt, kann man obigen Textblock
  per [INCLUDE] mehrfach wiederverwenden.)
- protocols [DIFF::3]: Wahlaufgabe zum Bereich X="Internet Protocols and Support"
- cryptoservice [DIFF::3]: Wahlaufgabe zum Bereich X="Cryptographic Services"
- fileformat [DIFF::3]: Wahlaufgabe zum Bereich X="File Formats"
- archives [DIFF::3]: Wahlaufgabe zum Bereich X="Data Compression and Archiving"


zu klären:


- os: sehr umfangreich, eventuell nur einzelne Teile?
- logging
- re: gehört vmtl eher zum Kapitel RegExp
- time: sollte das nochmal separat von datetime betrachtet werden oder mit in die Aufgabe
  integriert werden?
- sys
- collections
- math
- copy
- typing
- threading/multiprocessing
- warnings
- io
- uuid
- socket
- traceback
- base64
- operator


### Bibliotheken/pip-popular (N.N.)


- chardet (und charset-normalizer)




#### Bibliotheken/pip-popular pandas (N.N.)


- Pandas installieren, pandas101
- Struktur der Doku verstehen
- Theorie: Series, DataFrame, Index, MultiIndex: Zweck, Unterschiede, Gemeinsamkeiten.
- Pandas-Cheatsheet: CSV-Tabelle einlesen, diverse Arten von Datenumstrukturieren ausprobieren


#### Bibliotheken/pip-popular matplotlib (N.N.)


Assumes pandas


- matplotlib installieren
- Doku sichten, Grundkonzepte lernen (nämlich welche?)
- Barplot ausprobieren
- Boxplot ausprobieren
- Multi-Boxplot für Teilmengen von Variable B gemäß der Gruppen laut Variable A
- einen komplexen Plot nachahmen, der visuell vorliegt und viele Konfig-Anpassungen braucht
  (Namen der nötigen Konstrukte sind vorgegeben)
- Dito ohne Namensvorgaben.




### Bibliotheken/chooselib (N.N.)


Bibliothek für bestimmten Zweck suchen und erlernen.
Wichtige wiederkehrende Tätigkeit in einem Entwickler_innenleben.


- Wo findet man Bibliotheken? PyPI ("pei-pi-ei").
  Stichwortsuche ausprobieren und sein blaues Wunder erleben ob der vielen Resultate.
- Nach welchen Merkmalen wählt man eine Bibliothek aus?
  (Funktionsumfang, Qualität der Dokumentation, Popularität, Alter und Reife,
  kontinuierliche Pflege/Releases, Zustand Issuetracker, mag ich die Struktur der API?,
  Geschwindigkeit u.a. nichtfunktionale Eigenschaften, geringe Codegröße/Aufgeblähtheit,
  bisherige Sicherheitslücken und guter Umgang damit, ...)
- Wie entscheidet man über diese Merkmale? (Recherche nach Wissen anderer; Prototypen bauen)
- 3 Fallstudien dazu
- Grundkonzepte verstehen!
- Wie lernt man das Nötige für einen schmalen Anwendungsfall (Doku vs. stackoverflow vs. ChatGPT)?


### Bibliotheken/Posix (N.N.)


- Aufgaben zum Kennenlernen des Unterschieds zwischen Posix-System und anderen unixoiden (sprich: Linux).






## ch/Sprachen


### Sprachen/Shell (condric+hüster?)


Puh, wie man folgendes in eine vernünftige Lernreihenfolge bringt, ist nicht offensichtlich:  
Es wäre schön, die Trennung zwischen der Shellsprache (inkl. builtins) und den Utilities zu vermitteln.  
Ferner den Unterschied zwischen `sh` und `bash`.


Die Utilities gehören an sich nicht hierhin, sondern ins Kapitel `Werkzeuge`.
Vermutlich führt man hier von den allerwichtigsten Utilities (z.B. Dateihandling)
das Grundkonzept ein (weil man ohne sie nichts Sinnvolles tun kann) und
in `Werkzeuge` folgen später diverse Optionen und Varianten der Benutzung?


Wörter, Kommandos, einfaches Quoting, Globbing, Redirect, Pipe.
if, Tests, for, while, exit codes,
shell vars, env vars,
single vs. double quote, backquote,
Quotes um Variablenverwendungen wg. möglicher Blanks,
Shellprozeduren.


Typische Idiome in Shellskripten.




### Sprachen/Bash (condric+hüster?)


Die wichtigsten Erweiterungen ggü. sh bezüglich Sprache, Variablen, Builtins, etc.


Ziel: Verstehen, dass sh (auf allen Plattformen vorhanden, wenn auch nicht immer _genau_ gleich)
und bash (deutlich erweitert) verschiedene Dinge sind.




### Sprachen/Regexp (hüster)


Basiskurs in "einfach", fortgeschrittenes Zeug in "mittel".
Immer möglichst so eingekleidet, dass man einen realistischen Anwendungsfall kennenlernt.




### Sprachen/Python0 (alrwasheda)


Aufgaben mit DIFF1 als unvollkommene Starthilfe, überwiegend für Leute mit zu niedrigem Wissen.
Wiederholung (manches ist aber auch neu!) der absoluten Essentials:
Kontrollstrukturen: if, elif, else, for, while, etc.
Keywords: def, return, break, continue, etc.
Datenstrukturen: list, dict, set etc.
OOP: class, self, Vererbung, super(), Objekterzeugung etc.
Gemischtes: tuple unpacking, ...


Vermutlich sinnvoll als Lückentext, sodass sehr kleine und eingegrenzte Aufgaben entstehen?




### Sprachen/Python (alrwasheda)


Fortgeschrittenere Konstrukte:
Projektstruktur: import, packages, modules, __init__.py, etc.
Context: with, open
try/except, eigene Exceptions, realistische Ausnahmebehandlung (try except raise und das dann ganz woanders fangen),
Typdeklarationen für Parameter und Resultate, Modul typing,
Typdeklarationen für Attribute, fast alles aus
https://medium.com/@rosk.abed/why-python-is-the-best-programming-language-so-far-5e481804159b,
builtins (all, any, get/set/hasattr, isinstance/issubclass, advanced print/list/dict/set,
str/bytes, sum, zip etc.)
und anderes mehr.


Alternativlösung: wir weisen bei den Programmieraufgaben auf diese Konstrukte hin als
etwas, das man dabei lernen und benutzen kann oder soll.
Das ist aber nicht zielgenau, wenn die Aufgaben Spielraum bei der Entwurfsstruktur haben.


Aufgabe(n) zu den Dunder-Methoden von Klassen (z. B. `__init__`, `__bool__`, `__add__`,...) als
Folgeaufgabe zu ch/Sprachen/Python/PythonObjectsClassesIntro.md


String-Formatierung


### Sprachen/Pythonpraxis (prechelt)


1. Eine Reihe von Aufgaben, in denen nach und nach die CLI-Anwendung
`mlh` ("my little helpers") programmiert wird.
Diese bündelt eine Reihe kleiner Utilities und
setzt argparse mit subcommands ein, um das zu strukturieren.
Diese Anwendung können die TN nach dem ProPra mitnehmen und ein langes und
abenteuerreiches Leben lang weiterbenutzen (und ergänzen).


Ideen für Teilanwendungen (in alphabetischer Reihenfolge):


- `diffenv`: Ein Skript, das die Verwaltung von Umgebungsvariablen in
  verschiedenen Umgebungen (Entwicklung, Test, Produktion usw.) erleichtert, indem es die Mengen
  von Umgebungsvariablen-Definitionen in zwei Dateien vergleicht.
  Es ignoriert also im Gegensatz zu normalem `diff ` sowohl die Werte dieser Variablen
  als auch die Reihenfolge ihrer Definition.
  Zeilen, die nicht die Form `A=b` oder `export A=b` haben, können wahlweise ignoriert, gezählt,
  oder als Fehler (mit exit status) gemeldet werden.
  Mehrfache Definitionen derselben Variablen werden als Warnung gemeldet.
- `htmlprettify`: Liest ein HTML-Fragment von stdin und schreibt eine formatierte Fassung nach stdout.
- `sgrep`: Ein simples grep, das beliebige Trenner zulässt, anstatt immer nur '\n' als
  Trenner zu betrachten. Liest ggf. zunächst die ganze Datei in den Speicher.
  Default-Trenner ist '\n\n', sodass es ganze Absätze ausspuckt anstatt Zeilen.
  Trenner ist eine regexp. `--color` markiert den Trefferstring rot.
- `pythonfraction`: https://third-bit.com/2025/05/18/two-thirds-of-a-language/


2. Eine Anwendung `linkcheck`, die einen Crawler realisiert, der die Verfügbarkeit
von Teilen (HTML-Seiten, Bilder, JS-Dateien) in einem URL-Baum prüft und verschiedene
fortgeschrittene Eigenschaften hat.
Teilaufgaben:


- `findlinks`: mit `bs4` die verschiedenen Sorten von Links auf einer Webseite extrahieren
  und ggf. zu absoluten Links ergänzen. Guten HTML-Parser installieren.
  Der Start-URL wird per Kommandozeilenparameter angegeben.
- `ratelimit`: Links in `deque`-Warteschlange einstellen und nacheinander per `urllib3` abarbeiten.
  Dabei ein ratelimit einhalten, das per default 4 Requests pro Sekunde beträgt, aber
  per Option `--maxfreq` verändert werden kann.
  Geht der Request (1) an einen URL "unterhalb" des Start-URLs, wird die HTML-Seite abgerufen
  und Links darauf extrahiert, geht er (2) an eine andere Adresse auf demselben Server,
  (3) an einen andereren Server, oder (4) liefert er eine andere Art von Datei als HTML,
  passiert keine Weiterverfolgung.
  In den Fällen (2) und (3) wird HEAD benutzt statt GET.
  Der Statuscode wird registriert; Fehler werden ausgegeben.
- `multiqueue`: Jeder Server bekommt eine eigene Warteschlange.
  Wir betrachten jede Sekunde der Ausführung als einen Block, in dem jeder Server `maxfreq`
  Requests bekommen darf. Ist eine Sekunde bei einem Server "voll", wechseln wir zum nächsten.
  Gewartet wird nur (und zwar bis zum Ende der aktuellen Sekunde), wenn alle Server "voll" sind.
- `monitoring`: Wir erzeugen eine fortlaufende Statusausgabe und eine Datei mit den Fehlern.
- `async`:
- `mlh`: als Subkommando in `mlh` integrieren.




Ferner evtl:


- `Code-Snippets`: Ein Tool, das es Entwicklern ermöglicht, Code-Snippets zu organisieren,
  zu suchen und wiederzuverwenden; Evt. gut geeignet um auch mlh als code-snippets aufzunehmen?


### Sprachen/Go (brandes)
- Compiler installieren, IDE einrichten (GoLand bevorzugt)
- Hello World und ein paar Wörter über Packages
- Go für Python-Programmierer
  * Datentypen (casting und die meistbenutzten Typen)
  * Arrays, Slices, Maps
  * `if` und `for`, evtl. weitere einfachere Konstrukte
  * Funktionen (u. a. naked returns)
  * Pointers (evtl. im Zusammenhang mit C), pass-by-value oder -by-reference
  * Interfaces
- `go test`, `go build` und mehr zu Packages (Abhängigkeiten, `"go.mod"`)
- `go install` vs `go get` (das zweite ist deprecated, nur als `go get -d` benutzen fürs Herunterladen)
- File Management
  * file organizer - Dateien nach Typen sortieren
  * File system watcher?
- Multiprocessing (goroutines, channels, `select`, Mutex)
  * publisher/subscriber System
  * n-body Simulation?
  * Primzahlen bis n? (single- vs multithreaded, cpu/speicher trade-off)
  * job queue bzw. Task Scheduler?
- sqlite Integration
- Networking
  * (CRUD API?/ http messenger?)
  * file streaming über TCP
  * Paket-Inspector (TCP/UDP Paket Monitoring)
- Dependency Injection und Decorator Patterns (wichtig im Kontext von Go)
- generell - Go Standardbibliothek?
- COG: Cogs of Go (cli Anwendung ähnlich wie mlh)
  * `pin` - Alias zu dem Verzeichnis erstellen, wo das Kommando aufgerufen wurde;
  * `size` - Große von einer Datei bzw. einem Verzeichnis (Kombination von `du -sh` und `ls -l`);
  * `color` - Nimmt einen Hex-Farbcode (z. B. #123456) an und zeigt diese Farbe im Terminal;
  * `weather` - (vielleicht zu fortgeschritten) ip-address-geolocation-lookup + Wetterbericht für diesen Ort
- Effective Go, 100 Go Mistakes usw (https://github.com/dariubs/GoBooks)


### Sprachen/C (N.N.)


Kleiner Ausflug in die C-Programmierung, insbes. Zeiger, manuelle Speicherverwaltung.


- Compiler installieren, Hello World
- Datei einlesen, Länge der längsten und der kürzesten (nichtleeren) Zeile bestimmen
- Datei einlesen, kürzeste und längste Zeile aufbewahren (malloc).
  Wenn die längste Zeile sehr lang werden kann, muss man den Puffer immer wieder größer
  neu allokieren und den Inhalt umkopieren.
- malloc-Puffer überschreiten, Crash erleben
- lokale Variable int a = 7, b = 9; Stapel-Layout anschauen und verstehen.
  Wohin führt push: Zu höheren Adressen oder niedrigeren?
  Wie groß sind ints? Wie ist die Endianness?
- lokale Variable int16 a = 3, b = 4; *(char*)&a = "abcd"; a und b ansehen
- jetzt das Gleiche mit einem längeren String --> Crash
- Aus Unter-Unteraufruf gezielt eine lokale Variable im Unter-Aufruf verändern.
- Betriebssystemaufruf mit handgeklöppelter Datenstruktur machen
- Evtl. eine Aufgabe, in der eine enge Schleife in Python durch Auslagern nach C
  enorm viel beschleunigt wird? Der Rest des Codes bleibt in Python.
  Man schreibt sich also eine ganz kleine Bibliothek für einen Spezialalgorithmus in C
  und bindet sie an.




### Sprachen/SQL (ruhe)


Ein paar Aufgaben zu mittelkomplexen Abfragen (mit etwas Verschacheltung)
und mittelkomplexen Updates.  
Assumes: sqlite




### Sprachen/DSLs (N.N.)


- Was ist eine DSL? (interne, externe)
- Grundlagen/häufigste Fälle von awk
- Grundlagen/häufigste Fälle von sed
- `jq`, `jid`, `jgrep`




### Sprachen/Andere-Shells (N.N.)


Alternative Shells.


- Fish1: die netten interaktiven Eigenschaften ausprobieren. Reflektion darüber.
- Fish2: Ein Skript, das man oben für bash geschrieben (oder gelesen?) hat,
  nach `fish` umschreiben. Reflektion darüber.
- Zsh: Die Anpassbarkeit bestaunen. Evtl. [Oh my zsh](https://ohmyz.sh/) durchstöbern.
  Reflektion darüber.
- Powershell: 1-4 Aufgaben zu den ganz anderen Konzepten dieser Shell. (Ggf. eigene Gruppe.
  Geht nicht auf MacOS.)  
 




## ch/Testen (ruhe)


Folgende Voraussetzungen sollen gelten / geschaffen werden:


- Wichtige Begrifflichkeiten ist ein theoretischer Teil. Lesen und Antworten
- alle anderen Teilen sollen praktischer Natur sein
- hands-on Anteile sollen in GitHub realisiert werden
- Bestand
- optional: für die praktische Ausführung ein SuT mit zu findenden Fehlern entwickeln (FastAPI, Flask)


Aufgabenbereiche:


- Wichtige Begrifflichkeiten
  - Fehler, Defekt und Fehlerart
    - Übung
  - Testen, Debuggen und Qualitätssicherung
    - Übung
  - Testfall, Testsammlung, Testplan und Testdaten
    - Übung
- System Under Test (SuT)
  - Vorstellung des SuT
    - Bestandscode v1.0.0
    - Rest API Application v1.0.0, v1.1.0, v3.0.0
  - Implementierung
    - IDE
    - GitHub Action
- manuelles Testen
  - Testfälle erstellen in GitHub
  - Fehlerberichterstattung und -verfolgung in GitHub
- automatisiertes Testen
  - Testautomatisierungstools (Pytest, RF, Cypress, Locust, JMeter, SonarQube, Nessus)
  - Testarten
    - Unittests mit Pytest
    - Integrationstests mit RobotFramework
    - Systemtests mit Cypress (Optional + Cucumber mit Gherkin)
    - Last- und Performance Tests mit Locust
    - Sicherheitstests mit SonarQube (Nessus?)
    - Linter in der IDE
- Testdatenmanagement - statischer TF vs generischer TF
- Testabdeckung


- Resource: BugsInPy: a database of existing bugs in Python programs to enable controlled testing and debugging studies  
  <https://dl.acm.org/doi/10.1145/3368089.3417943>




## ch/Werkzeuge


### Werkzeuge/Bash2 (condric+hüster?)


- Umgang mit Dateien: ls, mv, rm, cp, mkdir, rmdir, ...  
  Lernziel: die Fälle verstehen, in denen das einer GUI überlegen ist: mit Globbing, mit mehreren Argumenten, mit speziellen Optionen
- Typische Helfer für die Shellprogrammierung: touch, cat, head, tail, grep, uniq, sort, find, awk, sed, xargs, tee, ...  
  Lernziel: Je mindestens einen gut erinnerbaren Anwendungsfall ausprobieren, in dem das Helferlein gute Dienste leistet.  
  Hier kommen natürlich nur noch die dran, die man nicht schon oben bei sprache/sh eingeführt hat.
- Typische Idiome der Shellprogrammierung.


Beispiele für interaktive Idiome:
- `cd -` zum Hin- und Herwechseln zwischen zwei Verzeichnissen
- Shellvars als Abkürzung für lange Verzeichnisnamen
- `find`, um junge Dateien in Baum zu finden
- `grep`, um eine Datei per eindeutigen Inhaltsschlagwort wiederzufinden (etc.)
- `find` mit `grep`, um Dateien mit Wort X drin zu finden, dann `ls -lt` um davon die jüngste zu finden
  (mit entsprechender Story dazu, warum das praktisch sein kann: Nadel im Heuhaufen finden)
- .bashrc: persönlicher PATH, ein schöner Prompt, praktische aliases u.v.a.m.


Beispiele für programmatische Idiome:
- ...


### Werkzeuge/Netzwerk (condric)


- ssh (mehrere Aufgaben)
  - ssh-agent (alias ins .bashrc)
  - tmux, ...
- ping, rsync, curl, wget, ...


Lernziel ist immer, typische Anwendungsfälle und Stärken zu verstehen.


### Werkzeuge/Admin (condric)


- lokales System, z.B. evtl.: w, uptime, whoami, df, du, tail -f, mount, ps, pgrep, kill/pkill, top/htop, ...  
  Lernziel: Situationen verstehen, in denen man das jeweils gebrauchen kann.
- Dateisystemaufbau: /bin, /usr, /var, /etc, /mnt, ...  
  Lernziel: Grobes Verständnis von "Was ist wo?"
- fortgeschrittenes Dateihandling: file, dd, tar, zip, gzip, ...
- root sein, z.B. evtl.: sudo (mit sudoers, visudo etc.), su, Ethos, Vorsicht, /etc/passwd, Gruppen/Gruppenrechte, ...


### Werkzeuge/Git (hüster)


Reizvolle didaktische Aufgabe!  
Was gehört zum Grundwissen, was ist schon deutlich fortgeschritten?  
Welche Konzepte muss man verstehen?  
Lernt man Idiome für häufige Situationen lieber durch selbererfinden oder wie Vokabeln?


- [Git Book 1.1](https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control) lesen.  
  Zwecke: Änderungen an Dateien und Dateinamen aufheben; Änderungen beschreiben (commit msg);
  Autoren und Zeitpunkte festhalten; Daten zwischen Rechnern synchronisieren; gleichzeitige Änderungen zusammenführen,
  Varianten parallel entwickeln (Zweige, branches); fremde Änderungen prüfen und übernehmen;
  fremde Änderungen teilweise übernehmen; Backup.  
  Welche zwei sind am wertvollsten und warum?  
  Welche zwei benutzt man am meisten und warum?
- Wie es funktioniert:
  [Git Book 1.3](https://git-scm.com/book/en/v2/Getting-Started-What-is-Git%3F) lesen;
  nur auf der Kommandozeile kann man git enträtseln;
  intern werden die Snapshots (versionierte Zustände des Dateibaums) dargestellt als drei Sorten von Objekten:
  blobs für Dateien, trees für Verzeichnisse (bestehend aus Pfadnamen mit zugehörigem blob oder tree),
  und commits für Snapshots.
  Jedes Objekt jeder Sorte wird durch einen Hashwert identifiziert.  
  Beispiel selber durchturnen: ...
- Logs, Refspecs
- Merge vs Rebase
- Ein Repo, mehrere Origins
- Arbeit mit Branches
- reset
- stash
- cherry-pick, rebase --interactive
- ...


Speziellerer Kram:


- Signing
- Squashing
- bisect
- ...




### Werkzeuge: sonstige Ideen


- Shell:
  - https://writing.kemitchell.com/2024/03/28/Pick-From-a-List-Tools
- IDE
  - Unterschied IDE und Editor
  - Projekterstellung
  - Code-Ausführung in der IDE
  - Debugging
  - Refactoring
  - git-Integration
  - Integriertes Terminal
- Paketmanager
  - Welche stehen in meiner Sprache zur Verfügung? Gibt es überhaupt welche?
  - Welche Funktionen bietet ein Paketmanager?
  - Wie finde ich Pakete?
  - Fallbeispiel über Probleme mit Paketmanagern
    - Eine der unzähligen Probleme mit npm heraussuchen, vielleicht mit einem Post Mortem.
      Aufgabe ist es herauszuarbeiten, was das Problem genau ist, ob es dauerhaft gefixt ist
      oder ob es überhaupt fixbar ist.
      Nicht als Draufprügeln für npm, sondern für das Verstehen, dass die Nutzung von Fremdcode
      unter der Hand explodieren kann.
- Arbeitsplatzergonomie
  - *Persönlich* finde ich wichtig, dass die Studierenden nicht nur ihre Arbeitsumgebung im PC,
    sondern auch um ihren PC herum einrichten können.
    Meistens denkt man da erst dran, wenn es zu spät ist.
    Maximal eine Aufgabe, darf nicht zu viel Platz beanspruchen.
- docker?




## ch/Web (müllers, hofmann)


- assumes: Wissen über http-Header, curl  
  https://icanhazdadjoke.com liefert im Browser etwas anderes als wenn man es mit curl abruft.
  Was vermuten Sie, wie funktioniert das? (User-Agent abfragen).
  Finden Sie eine Website, die Ihnen hilft zu prüfen, ob die Voraussetzung für ihre Vermutung
  gegeben ist.
- Auf Grundlagen beschränken; das ProPra ist kein Workshop für Spezialkenntnisse.  
- Frontend und Backend gemeinsam behandeln; Informatiker_innen sollten einen Überblick haben.
- Behandlung von folgenden Themen: HTML, CSS, ~~Bootstrap~~ Tailwind(?), JavaScript,
  evtl. TypeScript, Flask, Django, Vue(?), React(?).


### Strukturvorschlag (basierend auf dem Stand vor den Änderungen von Frau Atarim)


1. HTML
2. CSS
   - Jeweils eine Aufgabe für: Basics, häufig benutzte Eigenschaften Box Model, Selectors, (Pseudo)Classes
   - Es gab auch noch Shorthands (border statt border-left/-right/-top/-bottom)
     und Margin/Border/Padding, weil das besondere Relevanz hat. -> Aufgabe Box Model.
   - Medien-Abfragen, "responsive" Design
   - Fortgeschritten: Calculated Properties und Variablen, Grid und Flex
   - Optional: Verwenden von CSS Frameworks
3. JS
   - Verwenden von Ressourcen die JS für Python-Devs erklären.
   - Kurze Erwähnung, dass Syntax C-Style ist. Könnte man ggf. ausweisen.
     Erwähnung von function() {} vs () => {} als Frage, weil häufiger Stolperstein.
   - Einführung des DOM als Struktur mit einfachen Funktionen zur Manipulation
   - Einführung der asynchronen Struktur von JS.
     - Gegenüberstellung von Callbacks vs async await, ggf IIFE. für async
   - Kleines Beispielprogramm mit wiederkehrenden Elementen bauen lassen
     - Klischeebeispiel: Todo-Liste. Nett, weil hohes feature ceiling
   - Auf Basis des Programms Teplates und Slots motivieren und umsetzen.
     Nicht immer wieder die gleichen Elemente anlegen müssen!
   - Optional aufbauend auf Templates eigene Tags definieren.
     Hier würde ich die Semantic Tags kurz erwähnen.
   - Reactivity-Problem für die Template-Elemente erläutern.
     Beispiel: Durchstreichen nach Abhaken o.ä.
     Hier gibt es zwei Wege, das zu handlen:
     - Top-Down: Wir verwenden ein wenig von vue/reactivity und erklären anschließend,
       dass so etwas mit Proxy-Klassen selbst gebaut werden kann.
       Optionale nachfolgende Aufgabe: Proxy selbst implementieren!
     - Bottom-Up: Wir streichen Drittanbieter-Bibliotheken und bauen direkt selbst einen Proxy.
       Nett, weil wenig Fremd-Information, aber sehr mühsam mit vergleichsweise wenig Lerneffekt.
   - Shadow-DOM motivieren und ggf. mit Drittanbieter-Bibliothek anbinden
   - Struktur des Frameworks der Wahl präsentieren und zeigen, wie es das gelernte umsetzt.
4. Backend mit Python
  - Flask, Django?




# Aufgabenideen ohne Heimat


- Lektion: Kämpfe nicht gegen den Compiler an.
    - Sucht nach einer Umsetzung.
      Eine eigene Implementierung vs eine Implementierung der Standardbibliothek zu dekompilieren
      führt nicht zum Ziel, Python optimiert recht wenig.
- ORM mit Python (Django oder sqlalchemy)
- Lernmethoden und Lernressourcen:
    - https://earthly.dev/blog/golang-streamers/
    - https://earthly.dev/blog/programming-language-improvements/
- DB-Programmierung-Antimuster vermeiden: SQL-Injektion, n+1 Queries
- Praxis Datenbankdesign
- Vergleich von sqlite, mysql, postgres; evtl. selber Aufsetzen und Ausprobieren.
- Machine Learning: Einfache Gehversuche mit scikit-learn (dubios: braucht erstmal Theoriewissen)



